%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Uživatelská příručka}
\subsubsection{Základní pojmy}
\begin{framed}
  \begin{itemize}
    \item TODO: v teoretické části uvést pojmy znovu s citacemi
    \item TODO: production memory v exilu splývá s pravidly znalostní báze - na
      příhodném místě uvést, že v teorii a některých systémech se rozlišuje
  \end{itemize}
\end{framed}

Nyní stručně zadefinuji základní pojmy, nutné pro pochopení fungování knihovny
ExiL a práci s ní. Význam pojmů bude jasnější, jakmile si je ukážeme na
příkladech. K těmto pojmům se posléze vrátím i~v~teoretické části textu
a~jejich popis rozšířím o další souvislosti.

První dva pojmy staví na pojmu znalost, který chápeme intuitivně a nebudu se jej
ani snažit definovat, nikoli na následujícím pojmu znalosti, jak ji chápeme
v~ExiLu (v takovém případě by byla definice cyklická).

Pojem expertního systému zatím chápejme tak, jak jsem jej představil v úvodu
práce. V praktické části rozeberu pojem v potřebné šíři.
\begin{description}[leftmargin=6cm,style=sameline,align=right,labelsep=0.5cm]
  % \item[problémová doména] množina pojmů relevantních pro řešení určité skupiny
  %   problémů
  \item[fakt] elementární statická znalost - tvrzení
  \item[(odvozovací) pravidlo] elementární odvozovací znalost - pokud víme, že
    (ne)platí nějaká tvrzení, můžeme odvodit, že platí i~nějaká další
  \item[znalost (v ExiLu)] množina faktů a pravidel
  \item[znalostní báze] výchozí znalost expertního systému
  \item[pracovní paměť] aktuální množina faktů
  % \item[production memory] aktuální množina pravidel
  \item[inference] odvozování - postupná aplikace odvozovacích pravidel
\end{description}
Pojem \emph{pracovní paměť} není příliš intuitivní. Jde o doslovný překlad
v~literatuře užívaného pojmu \emph{working memory}, kterým je označována množina
faktů (tvrzení), které expertní systém v danou chvíli považuje za platné. Nejde
tedy ve skutečnosti o paměť, nýbrž o obsah pomyslné paměti. Pojem pracovní
množina faktů by byl jistě výstižnější, bohužel ale také značně těžkopádný.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Struktura programu}

\begin{listing}[h]
\caption{Základní struktura exilového programu}
\label{typical structure}
\begin{clcode}
;;; definition of knowledge base
;; facts
(deffacts world
  (in box A)
  (in robot B)
  (goal move box A B))

;; inference rules
(defrule move-robot
  (goal move ?object ?from ?to)
  (in ?object ?from)
  (- in robot ?from)
  (in robot ?z)
  =>
  (retract (in robot ?z))
  (assert (in robot ?from)))

(defrule move-object
  (goal move ?object ?from ?to)
  ?rob-pos <- (in robot ?from)
  ?obj-pos <- (in ?object ?from)
  =>
  (retract ?rob-pos)
  (retract ?obj-pos)
  (assert (in robot ?to))
  (assert (in ?object ?to)))

(defrule stop
  (goal move ?object ?from ?to)
  (in ?object ?to)
  =>
  (halt))

;;; initialization of working memory
(reset)

;;; inference execution
(run)
\end{clcode}
\end{listing}

Příklad \ref{typical structure} na straně \pageref{typical structure} ukazuje
minimální strukturu programu nad knihovnou ExiL (dále exilový program). První
část programu tvoří definice znalostní báze. Ta sestává z definic faktů, ze
kterých expertní systém vychází a definic odvozovacích pravidel, jež jsou
následně aplikována při inferenci.

Definice faktů jsou uspořádány do skupin označených názvem (v tomto případě
\verb|world|). V ukázkovém programu si snadno vystačíme s jednou skupinou faktů,
v reálných programech bude ale těchto skupin většinou více. Tato organizace
umožňuje snadnou redefinici, případně odebrání, jen některých skupin faktů v
případě potřeby.  Definice skupiny faktů \verb|world| v příkladu přidává do
znalostní báze informaci o~počáteční pozici robota, krabice a~o~našem záměru
přesunout krabici z~pozice \verb|A| na pozici \verb|B|.

Následuje definice odvozovacích pravidel. Definice každého pravidla sestává
z~množiny podmínek, tedy předpokladů pro jeho splnění (a následnou aktivaci),
a~množiny důsledků, tedy libovolných lispových lispových výrazů, které jsou při
aktivaci pravidla vyhodnoceny.  Tyto dvě množiny jsou od sebe odděleny
\emph{symbolem}~\verb|=>|.

Podmínky odvozovacích pravidel jsou ve formě vzorů (\emph{pattern}). Struktura
vzorů je stejná jako struktura faktů (viz sekce \ref{knowledge base
definition}), ale narozdíl od nich mohou obsahovat proměnné (symboly začínající
otazníkem).  Při vyhodnocování podmínek pravidla je zajišťěna
konzistence vazeb těchto proměnných a výskyty všech proměnných v~důsledcích
pravidla jsou při jeho aktivaci nahrazeny jejich vazbami. Detaily viz sekce
\ref{inference}

Důsledky pravidel typicky obsahují příkazy pro modifikaci pracovní paměti (viz
sekce \ref{modifikace}), tedy přidání (\verb|assert|), odebrání (\verb|retract|),
či úpravů (\verb|modify|) faktů v ní. Nemůsí
tomu tak ale být vždycky - důsledkem aktivace pravidla může být např. vypsání
výstupu, logování, zápis souboru, ale také např. ovládání externího systému.

Náš ukázkový příklad definuje tři odvozovací pravidla. Pravidlo
\verb|move-robot| je aktivováno, pokud chceme přesunout nějaký objekt z pozice
\verb|?from| na pozici \verb|?to|, objekt se nachází v pozici \verb|?from|
a~robot nikoli (třetí podmínka je negovaná, viz sekce \ref{knowledge base
definition}). Poslední podmínka slouží pouze k navázání původní pozice robota.
Při aktivaci pravidla je v pracovní paměti nahrazena informace o~původní pozici
robota pozicí \verb|?from|. Robot se tedy nyní nachází na stejné pozici, jako
kýžený objekt.

Podmínky pravidla \verb|move-object| vyžadují, aby byl jak robot, tak objekt
určený k přesunu, na pozici \verb|?from|. Při jeho aktivaci je robot i s objektem
přesunut na pozici \verb|?to| nahrazením faktů o původních pozicích novými,
podobně jako v prvním pravidle. Definice pravidla obsahuje speciální notaci (s
použitím operátoru \verb|<-|), jejímž účelem je navázání celého faktu na
proměnnou. Ten pak můžeme v důsledcích snadno ostranit z pracovní paměti.

Poslední pravidlo slouží k zastavení inference, pokud se již objekt nachází na
zamýšlené pozici. Inference je zde zastavena explicitním voláním \verb|(halt)|.
Druhou možností by bylo odstranit z pracovní paměti fakt definující cíl, neboť v
takovou chvíli nemůže být žádné další pravidlo splňeno.

Jakmile je znalostní báze nadefinována, můžeme z ní inicializovat pracovní
paměť. To provedeme voláním \verb|(reset)|, které (po případném vyčištění
původních faktů) přidá do pracovní paměti fakta ve všech definovaných skupinách.

Poslední nutnou fází exilového programu je spuštění inference. To můžeme udělat
nejjednodušeji voláním \verb|(run)|. Inferenční mechanismus poté postupně
vyhodnocuje, která odvozovací pravidla mají splněné všechny podmínky, v každém
kroku z nich jedno vybere a aktivuje jej. Detaily viz sekce \ref{inference}

Výstup programu je následující:
\begin{minted}{cl}
==> (IN ROBOT B)
==> (IN BOX A)
==> (GOAL MOVE BOX A B)
Firing MOVE-ROBOT
<== (IN ROBOT B)
==> (IN ROBOT A)
Firing MOVE-OBJECT
<== (IN ROBOT A)
<== (IN BOX A)
==> (IN ROBOT B)
==> (IN BOX B)
Firing STOP
Halting
\end{minted}
Řádky začínající symbolem \verb|==>| označují fakty přibyvší do pracovní paměti,
řádky začínající \verb|<==| fakty z paměti odstraněné. Tento výstup obdržíme
pouze pokud zapneme sledování faktů voláním \verb|(watch facts)| (viz sekce
\ref{inference tracing}). První tři fakty přibydou do pracovní paměti při
vyhodnocení volání \verb|(reset)|, další pak spolu s postupnou aplikací
odvozovacích pravidel. Dotážeme-li se po skončení inference na seznam faktů v
pracovní paměti voláním \verb|(facts)|, obdržíme výstup
\cl|((GOAL MOVE BOX A B) (IN ROBOT B) (IN BOX B)).|
Robot i krabice jsou tedy na cílové pozici.

Kód exilového programu má deklarativní charakter. Nikde jsme nemuseli
specifikovat, jakou posloupností akcí má systém k výsledku dospět. To nás ovšem
nezbavuje nutnosti chápat fungování inferenčního mechanismu ExiLu. Nebudeme-li
při konstrukci programu opatrní, může výpočet snadno dospět k neočekávaným
výsledkům, dostat se do slepé větve, či se zacyklit. Tyto problémy jsou často
způsobeny nezamýšlenou interferencí podmínek pravidel s důsledky jiných.

\FloatBarrier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Definice znalostní báze}
\label{knowledge base definition}
\begin{framed}
  \begin{itemize}
    \item skupiny faktů
    \item pravidla
      \begin{itemize}
        \item podmínky podrobně - patterny, konjunkce, negace
        \item důsledky - typicky modifikace pracovní paměti
      \end{itemize}
    \item queries - fact-groups, rules + finders
    \item přesunout přílišné podrobnosti do referenční příručky
  \end{itemize}
\end{framed}

ExiL, stejně jako CLIPS, rozlišuje dva typy faktů - jednoduché (\emph{simple,
ordered}) a strukturované (\emph{templated}). Stuktura jednoduchého faktu je udána
pouze pořadím \emph{atomů}, typickou volbou je např. \verb|objekt-attribut-hodnota|:
\cl|(box color red),| či \verb|relace-<zůčastněné objekty>|: \cl|(in box hall).|

Strukturované fakty mají naproti tomu explicitně pojmenované složky (sloty).
Typicky popisují objekt s množinou atributů: \cl|(box :color red :size small),|
či relaci s jasně danými aktory: \cl|(in :object box :location hall),| kde
\verb|box| a \verb|in| jsou šablony (\emph{template}), které je třeba definovat
předem. Na pořadí specifikace slotů u strukturovaných faktů
nezáleží.  Vyjadřovací síla obou typů faktů je stejná, použitím explicitnějších
strukturovaných faktů ale docílíme lepší čitelnosti a jednoznačnější sémantiky
exilového programu, zláště třeba v případě relací na jedné množině objektů:
\cl|(father john george).|

Šablonu definujeme voláním \emph{makra} \verb|deftemplate|, např:
\cl|(deftemplate in object (location :default here)).| Prvním parametrem je
název šablony, za ním následuje libovolný počet specifikací slotů. Specifikací
slotu je buď symbol - jméno slotu, nebo \emph{seznam}, jehož hlavou
(\emph{car}) je jméno slotu a~tělem (\emph{cdr}) je \emph{property list (plist)}
s dalšími parametry. Aktuálně systém umožňuje pouze specifikaci výchozí hodnoty
slotu \emph{klíčem} \verb|:default|. Ta je použita, není-li při specifikaci
faktu, používajícího tuto šablonu, uvedena hodnota pro daný slot.

Je-li už šablona požadovaného názvu definována, ale neexistují v pracovní
paměti fakty, které ji používají, je její stávající definice nahrazena. Pokud
ale v pracovní paměti existují takové fakty, skončí volání \verb|deftemplate|
výjimkou.

Seznam názvů všech definovaných šablon můžeme získat voláním \emph{funkce}
\verb|templates| (bez parametrů). Specifikaci šablony pak získáme voláním makra
\verb|find-template|, např. \verb|(find-template in).|

Fakta, ze kterých expertní systém vychází zavádíme pomocí skupin faktů. Ty
definujeme makrem \verb|deffacts|, např.:
\begin{minted}{cl}
(deffacts initial
  (goal move box A B)
  (in :object box :location A))
\end{minted}
Prvním parametrem je název skupiny, pak následuje libovolný počet specifikací
faktů. Specifikace faktu je vždy tvořena seznamem. Pokud jde o jednoduchý fakt,
specifikací je prostě seznam atomů. Jde-li o fakt strukturovaný, je prvním
prvkem specifikace název šablony, za ním následuje plist určující hodnoty slotů
faktu.

Pravidla - podmínky, důsledky, queries

Podmínky pravidel jsou ve formě vzorů (\emph{pattern}). Struktura vzorů je
stejná jako struktura faktů, ale narozdíl od nich mohou obsahovat proměnné
(atomy začínající symbolem otazníku). Krom toho mohou být podmínky negovány.
Taková podmínka je splněna tehdy, pokud neexistuje žádný fakt, který by jí
odpovídal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Modifikace pracovní paměti}
\label{modifikace}
\begin{framed}
  \begin{itemize}
    \item inicializace ze znalostní báze
    \item ruční modifikace - assert, retract, modify
    \item queries - facts
  \end{itemize}
\end{framed}

Pracovní paměť může být dále v průběhu inference modifikována třemi makry:
\begin{itemize}
  \item \verb|assert| přidává fakt(a) do pracovní paměti,
  \item \verb|retract| fakt(a) z pracovní paměti odebírá a
  \item \verb|modify| přímo modifikuje existující fakta.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Inference}
\label{inference}
\begin{framed}
  \begin{itemize}
    \item fáze podrobně
    \begin{itemize}
      \item vyhodnocení podmínek - statické testy, vazby proměnných (speciální -
        singleton, navázání faktu), konzistence
      \item výběr pravidla - strategie
      \item aktivace - vyhodnocení důsledků (typicky modifikace pracovní paměti)
        navázání proměnných, eval
    \end{itemize}
    \item spuštění inference, krokování (může se prolínat s ručnímodifikací w.m.)
    \item queries - agenda, strategies
  \end{itemize}
\end{framed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Reset prostředí}
\begin{framed}
  \begin{itemize}
    \item durable/volatile slots
    \item clean, reset, complete reset (neměl by se jmenovat complete clean?)
  \end{itemize}
\end{framed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Sledování průběhu inference}
\label{inference tracing}
\begin{framed}
  \begin{itemize}
    \item watchery
  \end{itemize}
\end{framed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Undo/redo}
\begin{framed}
  \begin{itemize}
    \item lze použít na všechny funkce/makra s vedlejším efektem
    \item pokud funkce nemá vedlejší efekt (fakt neexistuje, apod.), nezapíše se
      undo step
    \item queries - undo-stack, redo-stack
  \end{itemize}
\end{framed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zpětné řetězení}
\begin{framed}
  \begin{itemize}
    \item cíle jako patterny
    \item základní inference - nejdřív fakta, pak pravidla, v jakém pořadí
      vybírá
    \item alternativní odpovědi - backtracking
  \end{itemize}
\end{framed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Práce s více prostředími}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Grafické uživatelské rozhraní}
