%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Popis implementace}
Knihovna je napsána v~programovacím jazyku Common Lisp. K~jejímu vývoji jsem
použil textový editor \textsf{GNU Emacs} s~rozšířením \textsf{SLIME} (The
Superior Lisp Interaction Mode for Emacs) a kompilátor \textsf{SBCL} (Steel Bank
Common Lisp). Vývoj jsem prováděl na architektuře \textsf{GNU/Linux x86}.
Funkčnost knihovny jsem testoval také ve vývojovém prostředí
LispWorks\textsuperscript{\textregistered}.

Zdrojový kód knihovny je rozdělen celkem do 15 souborů:
\begin{verbatim}
        packages.lisp
        utils.lisp
        templates.lisp
        facts.lisp
        patterns.lisp
        rules.lisp
        rete-generic-node.lisp
        rete-alpha-part.lisp
        rete-beta-part.lisp
        rete-net-creation.lisp
        matches.lisp
        activations.lisp
        strategies.lisp
        environment.lisp
        export.lisp
\end{verbatim}
\begin{itemize}
\item V~souboru \verb|packages.lisp| definuji package (\uv{balíček}) \verb|exil|,
který bude definované funkce, metody a makra obsahovat.
\item Soubor \verb|utils.lisp| obsahuje jednoduché obecné funkce a makra, které
jsem během vývoje pro zjednodušení další práce napsal.
\item V~souboru \verb|export.lisp| jsou všechny metody a makra, které knihovna
poskytuje uživateli. Tyto jsou z~package \verb|exil| exportovány, lze je
tedy volat bez nutnosti vstupu do package (před název je třeba připojit
``\verb|exil:|'').
\item Ve zbytku souborů definuji jednotlivé třídy a metody. Kód v~každém ze
souborů staví na konstruktech definovaných v~předchozích souborech. Prostředí
(třída \verb|environment|), definovaná ve stejnojmenném souboru nakonec všechny
dříve definované třídy zakomponuje do jednoho celku a vytvoří celek, na kterém
může soubor \verb|export| vystavět makra, která uživatel bude nakonec používat.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Templates}
Soubor vytváří základní mechanismus pro práci se strukturovanými daty.
Třída \verb|template| obsahuje sloty pro uchování informací o~uživatelsky
definovaných šablonách. Všechna strukturovaná data nebo patterny jsou pak
instancemi tříd odvozených od \verb|template-object|. Při vytváření těchto
instancí mechanismus prochází kromě inicializačních parametrů také specifikaci
slotů uloženou v~konkrétní instanci třídy \verb|template| a tak umožňuje
nastavení implicitnch hodnot. Krom toho soubor definuje predikát
\verb|tmpl-object-specification-p|, který podle specifikace faktu (resp.
patternu) určí, jde-li o~fakt jednoduchý či strukturovaný.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Facts a Patterns}
Definice základních datových struktur \verb|fact| a \verb|pattern| a od nich
odvozených \verb|simple-fact|, \verb|template-fact|, \verb|simple-pattern|
a \verb|template-pattern|. Nevyžaduje hlubšího popisu.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rules}
Definice třídy \verb|rule| pro uchování inferenčních pravidel. Třída nese
informace o~jméně pravidla, jeho podmínkách (typu \verb|pattern|) a aktivacích
(prostý seznam lispových výrazů, které se při aktivaci pravidla postupně
vyhodnotí).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rete}
Algoritmus Rete je nejsložitější částí implementace knihovny, jeho kód je tedy
pochopitelně nejdelší. Je rozdělen do čtyř souborů.

První z~nich, \verb|rete-generic-node| definuje třídu \verb|node|, která je
základem všech uzlů dataflow sítě algoritmu. Tím je zajištěno, že každý uzel
sítě uchovává seznam svých potomků a implementuje metody \verb|activate|
a \verb|inactivate|, skrze něž je svým rodičem upozorňován na změny ve znalostní
bázi. Každý typ uzlu na tyto aktivace reaguje jinak.

Implementace aktivací konkrétních souborů zabírá většinu kódu následujícíh dvou
souborů -- \verb|rete-alpha-part| a \verb|rete-beta-part|. Kořenem celé dataflow
sítě algoritmu Rete je \verb|alpha-top-node|. Ten uchovává hashovací tabulku
jednotlivých podsítí alfa-sítě podle typu šablony faktů, které ta která síť
testuje. Je zde navíc jedna podsíť pro fakta jednoduchá (ta nemají šablonu).

Jakmile je určena podsíť, jíž bude nově přidaný (resp. odebraný) fakt procházet,
je aktivovaný příslušný \uv{podkořen} (\verb|alpha-subtop-node|), ten už má
potomky typu \verb|alpha-test-node|. Při průchodu každým testovacím uzlem je
otestován jeden atom fakta. Poslední testovací uzel předá při kladném výsledku
testu fakt paměťovému uzlu (\verb|alpha-memory-node|), ten si jej uloží
a pošle ho beta části sítě.

V~souboru \verb|rete-beta-part| je kromě jednotlivých typů uzlů definována třída
\verb|token|, uchovávající skupinu faktů prošlých podmínkami inferenčního 
pravidla. Relativně zajímavým prvkem je zde také přístup k~testování  kozistence
vazeb proměnných mezi jednotlivými podmínkami pravidla. Algoritmus zde při
aktivaci spojovacího uzlu (\verb|beta-join-node| a \verb|beta-negative-node|)
vůbec nehledí na konkrétní proměnné, jak by čtenář mohl očekávat. Při tvorbě
dataflow sítě je totiž pro každý spojovací uzel vytvořen seznam objektů typu
\verb|test|. Každý test slouží k~otestování konzistence jednoho pole aktuální
podmínky s~předchozími podmínkami. Test obsahuje tři hodnoty -- název (v~případě
strukturovaného patternu podmínky) či index (v~případě nestrukturovaného)
pole aktuálně testované podmínky, číslo značící, o~kolik podmínek zpět má hledat
konzistentní pole a název či index tohoto pole.

Pro lepší porozumnění uvedu příklad. Mějme pravidlo
\begin{verbatim}
(defrule find-green-block-on-a-red-one
  (green ?x)
  (red ?y)
  (on ?x ?y)
=>
  ; aktivace nas nezajimaji)
\end{verbatim}
a sestavme testy pro \verb|beta-join-node| testující konzistenci mezi vazbami
proměnných ve třetí podmínce proti podmínkám předchozím. Podmínky jsou typu
nestrukturovaných patternů, pole číslujme od 0. Test konzistentní vazby
proměnné \verb|?x| bude mít hodnoty \verb|(1 2 1)|, testujeme totiž pole
aktuální podmínky s~indexem 1 proti poli s~indexem 1 podmínky o~2 zpět.
Pokud je prostřední hodnota testu 0, znamená to, že testujeme konzistenci vazby
jen v~rámci aktuální podmínky. To se může stát, objevuje-li se daná proměnná
v~podmínce vícekrát. Test vazby proměnné \verb|?y| bude mít, jen pro úplnost,
hodnoty \verb|(2 1 1)|.

Jak tedy vidíme, hotový \verb|beta-join-node| na proměnné už vůbec nehledí,
jen mechanicky vykoná testy a skončí-li všechny úspěšně, přidá k~tokenu
fakt prošlý aktuální podmínkou a aktivuje jím své potomky (ty jsou typu
\verb|beta-memory-node|).

Testování se poněkud komplikuje u~negativních spojovacích uzlů
(\verb|beta-negative-node|). Zde musíme při každé aktivaci (přidání nového
faktu) zkontrolovat, zde není konzistetní s~některými z~dosud prošlých tokenů.
Pokud takovou shodu nalezneme, je třeba informovat potomky, aby všechny
tokeny s~těmito fakty ze svých proměnných odstranily. Při inaktivaci
(odstranění faktu ze znalostní báze) je naopak třeba zkontrolovat, zda to
nebyl poslední fakt, který danému tokenu v~nesplnění testu bránil (nezapomínejme
že je řeč o~negativních uzlech). Pokud tomu tak je, je třeba tokenem aktivovat
potomky uzlu.

Kdyby nám nezáleželo na efektivitě, bylo by implementačně nejjednodušší po
každé aktivaci (resp. inaktivaci) přepočítat možné shody veškerých tokenů
v~rodičovské beta-paměti proti všem faktům z~alfa-paměti. Toto je ale
neúnosně časově náročné. Přidal jsem proto k~tomuto účelu do třídy \verb|token|
ještě slot, v~němž si token v~paměti negativního spojovacího uzlu uchovává
seznam konzistentních faktů, jež mu brání v~úspěšném nesplnění testů. Když
je negativní uzel inaktivován odebráním faktu ze znalostní báze, stačí
jen odstranit fakt z~těchto seznamů v~tokenech a je-li po tomto odstranění
seznam některého tokenu prázdný, může tento pokračovat dataflow sítí níže.

\verb|Beta-memory-node| má kromě uchovávání tokenů ještě jednu funkci --
slouží jako produkční uzel -- lze v~něm uložit seznam pravidel, která jsou
uloženými tokeny splněna. Uzel tedy v~případě aktivace novým tokenem
zkontroluje, zda nějaká pravidla v~seznamu má a pokud ano, zavolá metodu
\verb|add-match| a předá jí splněné pravidlo a token, jenž jeho podmínkami
prošel. Tento pár (označovaný jako \verb|match|) je poté přidán k~agendě.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matches}
Soubor \verb|matches| definuje třídu \verb|match|. Dokud jsem nezačal
implementovat různé strategie pro výběr pravidla k~aktivaci, ukládal jsem
v~agendě jen páry (pravidlo . token) a této třídy nebylo třeba. Některé strategie ale
při výběru pravidla zkoumají, kdy bylo pravidlo na agendu přidáno. To si
vyžádalo definici vlastní třídy \verb|match|, která tuto informaci kromě
pravidla a tokenu uchovává.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Activations}
Metody definované v~souboru \verb|activations| řeší samotnou aktivaci pravidla.
Výrazy v~seznamu aktivací totiž není možné bez předchozí úpravy vyhodnotit,
neboť velice často obsahují proměnné navázané v~podmínkách. Je tedy třeba
z~kombinace seznamu podmínek pravidla a tokenu, který pravidlo splnil dostat
vazby těchto proměnných. Proměnné v~aktivacích jsou poté nahrazeny takto
zjištěnými atomy a teprve tehdy je možno aktivace vyhodnotit.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Strategies}
Soubor \verb|strategies| obsahuje definice jednotlivých strategií pro výběr
pravidla z~agendy k~následující aktivaci. Jde tedy pouze o~seznam funkcí,
kterým je agenda jako parametr předána a ony jeden z~objektů typu \verb|match|
vrátí. Ten je poté z~agendy odstraněn.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Environment}
V~souboru \verb|environment| definuji třídu stejného jména, která pouze
zastřešuje všechny doposud definované konstrukty. Obsahuje seznam definovaných
šablon, znalostní bázi faktů, definované skupiny faktů, seznam pravidel
a agendu. Kromě toho obsahuje instanci třídy \verb|rete| (jejíž jediným
zajímavým prvkem je odkaz na kořen stromu dataflow sítě) seznam definovaných
strategií a název aktuálně zvolené strategie. Posledním prvkem prostředí
je seznam aktuálně aktivních \emph{watcherů}, tedy sledovaných objektů
(viz \ref{watchers}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
