utils.lisp:(defun intern (string &optional (package *package*))
utils.lisp:  (defun string-append (&rest strings)
utils.lisp:(defgeneric symbol-name (symbol)
utils.lisp:(defun symbol-append (&rest symbols)
utils.lisp:(defun to-keyword (symbol)
utils.lisp:(defun from-keyword (key &optional (package *package*))
utils.lisp:(defmacro mac-exp (&body body)
utils.lisp:(defun subsets (list)
utils.lisp:(defun assoc-value (key alist)
utils.lisp:(defun (setf assoc-value) (value key alist)
utils.lisp:(defun assoc-key (value alist)
utils.lisp:(defun to-list (x)
utils.lisp:(defun to-list-of-lists (list)
utils.lisp:(defmacro my-pushnew (item place &key (test '#'equalp) (key '#'identity))
utils.lisp:(defmacro ext-pushnew (item place &key (test '#'equalp) (key '#'identity))
utils.lisp:(defmacro ext-delete (item place &key (test '#'equalp) (key '#'identity))
utils.lisp:(defmacro diff-delete (item sequence &key (test '#'equalp) (key '#'identity))
utils.lisp:(defmacro push-update (item place &key (test '#'equalp) (key '#'identity))
utils.lisp:(defun class-slot-value (class-name slot-name)
utils.lisp:(defun select (list &rest indices)
templates.lisp:(defun variable-p (expr)
templates.lisp:(defclass template ()
templates.lisp:(defmethod tmpl-slot-spec ((template template) slot-name)
templates.lisp:(defmethod tmpl-equal-p ((tmpl1 template) (tmpl2 template))
templates.lisp:(defmethod print-object ((tmpl template) stream)
templates.lisp:(defun field->slot-designator (field)
templates.lisp:(defclass template-object ()
templates.lisp:(defmethod tmpl-object-slot-value ((object template-object) slot-name)
templates.lisp:(defmethod tmpl-object-equal-p ((object1 template-object) (object2 template-object))
templates.lisp:(defmethod print-object ((object template-object) stream)
templates.lisp:(defmethod find-atom (atom (object template-object))
templates.lisp:(defmethod atom-postition (atom (object template-object))
templates.lisp:(defgeneric find-template (name))
templates.lisp:(defun tmpl-object (specification object-type)
templates.lisp:(defun tmpl-object-specification-p (specification)
facts.lisp:(defclass fact () ())
facts.lisp:(defgeneric fact-equal-p (fact1 fact2)
facts.lisp:(defclass simple-fact (fact)
facts.lisp:(defmethod initialize-instance :after ((simple-fact simple-fact) &key)
facts.lisp:(defmethod print-object ((fact simple-fact) stream)
facts.lisp:(defmethod fact-equal-p ((fact1 simple-fact) (fact2 simple-fact))
facts.lisp:(defmethod find-atom (atom (fact simple-fact))
facts.lisp:(defmethod atom-postition (atom (fact simple-fact))
facts.lisp:(defclass template-fact (fact template-object) ())
facts.lisp:(defmethod initialize-instance :after ((fact template-fact) &key)
facts.lisp:(defmethod tmpl-fact-slot-value ((fact template-fact) slot-name)
facts.lisp:(defmethod fact-equal-p ((fact1 template-fact) (fact2 template-fact))
facts.lisp:(defgeneric fact-field (fact field)
facts.lisp:(defun tmpl-fact (fact-spec)
facts.lisp:(defun tmpl-fact-specification-p (fact-spec)
facts.lisp:(defun make-fact (fact-spec)
patterns.lisp:(defgeneric atom-equal-p (object1 object2)
patterns.lisp:(defun constant-test (desired-value real-value)
patterns.lisp:(defclass pattern () ((negated :initform nil
patterns.lisp:(defgeneric pattern-equal-p (pattern1 pattern2)
patterns.lisp:(defclass simple-pattern (pattern)
patterns.lisp:(defmethod print-object ((pattern simple-pattern) stream)
patterns.lisp:(defmethod pattern-equal-p ((pattern1 simple-pattern) (pattern2 simple-pattern))
patterns.lisp:(defun var-or-equal-p (atom1 atom2)
patterns.lisp:(defmethod pattern-const-equal-p ((pattern1 simple-pattern)
patterns.lisp:(defmethod find-atom (atom (pattern simple-pattern))
patterns.lisp:(defmethod atom-postition (atom (pattern simple-pattern))
patterns.lisp:(defclass template-pattern (pattern template-object)
patterns.lisp:(defmethod tmpl-pattern-slot-value ((pattern template-pattern) slot-name)
patterns.lisp:(defmethod pattern-equal-p ((pattern1 template-pattern) (pattern2 template-pattern))
patterns.lisp:(defgeneric pattern-field (pattern field)
patterns.lisp:(defun tmpl-pattern (pattern-spec &optional (negated nil))
patterns.lisp:(defun tmpl-pattern-specification-p (specification)
patterns.lisp:(defun make-pattern (specification)
patterns.lisp:(defmethod print-object ((object template-pattern) stream)
rules.lisp:(defclass rule ()
rules.lisp:(defmethod rule-equal-p ((rule1 rule) (rule2 rule))
rules.lisp:(defmethod rule-equal-p ((rule1 rule) (rule2 rule))
rules.lisp:(defmethod print-object ((rule rule) stream)
rete-generic-node.lisp:(defclass described-object () ((description :initarg :description
rete-generic-node.lisp:(defmethod print-object :after ((object described-object) stream)
rete-generic-node.lisp:(defclass node (described-object) ((children :accessor children :initform ())))
rete-generic-node.lisp:(defgeneric node-equal-p (node1 node2)
rete-generic-node.lisp:(defmethod add-child ((node node) (child node))
rete-generic-node.lisp:(defmethod add-children ((node node) (children list))
rete-generic-node.lisp:(defgeneric activate (node object)
rete-generic-node.lisp:(defgeneric activate-children (node object)
rete-generic-node.lisp:(defgeneric inactivate (node object))
rete-generic-node.lisp:(defmethod inactivate-children ((node node) object)
rete-generic-node.lisp:(defmethod inactivate ((node node) object)
rete-generic-node.lisp:(defclass memory-node (node) ((items :accessor items :initform ())))
rete-generic-node.lisp:(defmethod add-item ((node memory-node) item &optional (equality-predicate #'equalp))
rete-alpha-part.lisp:(defclass alpha-node (node) ())
rete-alpha-part.lisp:(defclass alpha-test-node (alpha-node)
rete-alpha-part.lisp:(defmethod node-equal-p ((node1 alpha-test-node)
rete-alpha-part.lisp:(defmethod print-object ((node alpha-test-node) stream)
rete-alpha-part.lisp:(defgeneric test (node wme)
rete-alpha-part.lisp:(defmethod activate-children ((node alpha-test-node) (wme fact))
rete-alpha-part.lisp:(defmethod activate-memory ((node alpha-test-node) (wme fact))
rete-alpha-part.lisp:(defmethod activate ((node alpha-test-node) (wme fact))
rete-alpha-part.lisp:(defmethod inactivate :after ((node alpha-test-node) (wme fact))
rete-alpha-part.lisp:(defclass simple-fact-alpha-node (alpha-node) ())
rete-alpha-part.lisp:(defclass template-fact-alpha-node (alpha-node) ())
rete-alpha-part.lisp:(defclass simple-fact-test-node (alpha-test-node simple-fact-alpha-node) ())
rete-alpha-part.lisp:(defmethod test ((node simple-fact-test-node) (wme simple-fact))
rete-alpha-part.lisp:(defclass template-fact-test-node (alpha-test-node template-fact-alpha-node) ())
rete-alpha-part.lisp:(defmethod test ((node template-fact-test-node) (wme template-fact))
rete-alpha-part.lisp:(defclass alpha-subtop-node (alpha-node) ())
rete-alpha-part.lisp:(defmethod activate ((node alpha-subtop-node) (wme fact))
rete-alpha-part.lisp:(defclass simple-fact-subtop-node (alpha-subtop-node simple-fact-alpha-node) ())
rete-alpha-part.lisp:(defclass template-fact-subtop-node (alpha-subtop-node template-fact-alpha-node) ())
rete-alpha-part.lisp:(defclass alpha-top-node (alpha-node)
rete-alpha-part.lisp:;(defmethod initialize-instance :after ((node alpha-top-node) &key)
rete-alpha-part.lisp:(defmethod get-network ((node alpha-top-node)
rete-alpha-part.lisp:(defmethod (setf get-network) (value (node alpha-top-node)
rete-alpha-part.lisp:(defmethod initialize-network ((node alpha-top-node)
rete-alpha-part.lisp:(defmethod get/initialize-network ((node alpha-top-node)
rete-alpha-part.lisp:(defmethod initialize-instance :after ((node alpha-top-node) &key)
rete-alpha-part.lisp:(defmethod activate ((node alpha-top-node) (wme fact))
rete-alpha-part.lisp:(defmethod inactivate ((node alpha-top-node) (wme fact))
rete-alpha-part.lisp:(defclass alpha-memory-node (alpha-node memory-node) ())
rete-alpha-part.lisp:(defmethod activate ((node alpha-memory-node) (wme fact))
rete-alpha-part.lisp:(defmethod inactivate ((node alpha-memory-node) (wme fact))
rete-beta-part.lisp:(defclass beta-node (node) ((parent :accessor parent :initarg :parent
rete-beta-part.lisp:(defclass token () ((parent :reader parent :initarg :parent :initform nil)
rete-beta-part.lisp:(defclass empty-token (token) ((wme :initform nil)))
rete-beta-part.lisp:(defmethod token (wme &optional parent)
rete-beta-part.lisp:(defmethod previous-wme ((token token) &optional (n 1))
rete-beta-part.lisp:(defmethod includes-p ((fact fact) (token token))
rete-beta-part.lisp:(defmethod includes-p ((included-token token) (token token))
rete-beta-part.lisp:(defmethod print-object ((token token) stream)
rete-beta-part.lisp:(defgeneric token-equal-p (token1 token2)
rete-beta-part.lisp:(defmethod token->list ((token token))
rete-beta-part.lisp:(defclass beta-memory-node (beta-node memory-node)
rete-beta-part.lisp:(defgeneric agenda ())
rete-beta-part.lisp:(defgeneric add-match (rule token))
rete-beta-part.lisp:(defgeneric remove-match (rule token))
rete-beta-part.lisp:(defmethod complete-match ((node beta-memory-node) (token token))
rete-beta-part.lisp:(defmethod activate ((node beta-memory-node) (token token))
rete-beta-part.lisp:(defmethod broken-match ((node beta-memory-node) (token token))
rete-beta-part.lisp:(defmethod inactivate :before ((node beta-memory-node) (fact fact))
rete-beta-part.lisp:(defmethod inactivate :before ((node beta-memory-node) (token token))
rete-beta-part.lisp:(defmethod add-production ((node beta-memory-node) (production rule))
rete-beta-part.lisp:(defmethod delete-production ((node beta-memory-node) (production rule))
rete-beta-part.lisp:(defmethod print-object ((node beta-memory-node) stream)
rete-beta-part.lisp:(defclass beta-top-node (beta-memory-node) 
rete-beta-part.lisp:(defclass test () ((current-field-to-test
rete-beta-part.lisp:(defun make-test (current-field previous-condition previous-field)
rete-beta-part.lisp:(defmethod print-object ((test test) stream)
rete-beta-part.lisp:(defmethod test-equal-p ((test1 test) (test2 test))
rete-beta-part.lisp:(defmethod tests-equal-p ((test-list1 list) (test-list2 list))
rete-beta-part.lisp:(defclass beta-join-node (beta-node)
rete-beta-part.lisp:(defmethod initialize-instance :after ((node beta-join-node)
rete-beta-part.lisp:(defmethod beta-memory ((node beta-join-node))
rete-beta-part.lisp:(defmethod perform-join-test ((test test) (token token) (wme fact))
rete-beta-part.lisp:(defmethod perform-join-tests ((tests list) (token token) (wme fact))
rete-beta-part.lisp:(defmethod activate ((node beta-join-node) (token token))
rete-beta-part.lisp:(defmethod activate ((node beta-join-node) (wme fact))
rete-beta-part.lisp:(defmethod node-equal-p ((node1 beta-join-node)
rete-beta-part.lisp:(defclass beta-negative-node (beta-join-node memory-node) ())
rete-beta-part.lisp:(defmethod get-bad-wmes ((node beta-negative-node) (token token))
rete-beta-part.lisp:(defmethod activate ((node beta-negative-node) (token token))
rete-beta-part.lisp:(defmethod activate ((node beta-negative-node) (wme fact))
rete-beta-part.lisp:(defmethod inactivate ((node beta-negative-node) (wme fact))
rete-beta-part.lisp:(defgeneric rete ())
rete-beta-part.lisp:(defclass rete () ((alpha-top-node :reader alpha-top-node
rete-beta-part.lisp:(defmethod add-wme ((fact fact) &optional (rete (rete)))
rete-beta-part.lisp:(defmethod remove-wme ((fact fact) &optional (rete (rete)))
rete-net-creation.lisp:(defmethod find-test-node ((parent alpha-node) field value)
rete-net-creation.lisp:(defmethod find/create-test-node% (parent field value new-node-type)
rete-net-creation.lisp:(defgeneric find/create-test-node (parent field value)
rete-net-creation.lisp:(defmethod create-alpha-net% ((pattern simple-pattern) (root simple-fact-subtop-node))
rete-net-creation.lisp:(defmethod create-alpha-net% ((pattern template-pattern) (root template-fact-subtop-node))
rete-net-creation.lisp:(defmethod create-alpha-net ((pattern simple-pattern) &optional (rete (rete)))
rete-net-creation.lisp:(defmethod create-alpha-net ((pattern template-pattern) &optional (rete (rete)))
rete-net-creation.lisp:(defun find-atom-in-cond-list% (atom cond-list)
rete-net-creation.lisp:(defmethod get-intercondition-tests% ((condition simple-pattern) (prev-conds list))
rete-net-creation.lisp:(defmethod get-intercondition-tests% ((condition template-pattern) (prev-conds list))
rete-net-creation.lisp:(defmethod get-intracondition-tests% ((condition simple-pattern))
rete-net-creation.lisp:(defmethod get-intracondition-tests% ((condition template-pattern))
rete-net-creation.lisp:(defmethod get-join-tests-from-condition ((condition pattern)
rete-net-creation.lisp:(defmethod find/create-join-node ((parent beta-memory-node)
rete-net-creation.lisp:(defmethod find/create-neg-node ((parent beta-memory-node)
rete-net-creation.lisp:(defmethod new-production ((rule rule) &optional (rete (rete)))
rete-net-creation.lisp:(defmethod remove-production ((rule rule) &optional (rete (rete)))
matches.lisp:(defclass match () ((rule :initarg :rule :reader match-rule
matches.lisp:(defun make-match (rule token &optional (timestamp (get-internal-real-time)))
matches.lisp:(defmethod match-equal-p ((match1 match) (match2 match))
matches.lisp:(defmethod print-object ((match match) stream)
activations.lisp:(defmethod variable-bindings ((pattern simple-pattern) (fact simple-fact))
activations.lisp:(defmethod variable-bindings ((pattern template-pattern) (fact template-fact))
activations.lisp:(defun get-variable-bindings (pattern-list fact-list)
activations.lisp:(defun substitute-variables (tree var-bind-list)
activations.lisp:(defmethod activate-rule ((activation match))
strategies.lisp:(defmethod newer-than ((match1 match) (match2 match))
strategies.lisp:(defun depth-strategy (agenda)
strategies.lisp:(defun breadth-strategy (agenda)
strategies.lisp:(defmethod simpler-than ((rule1 rule) (rule2 rule))
strategies.lisp:(defmethod simpler-than ((match1 match) (match2 match))
strategies.lisp:(defun simplicity-strategy (agenda)
strategies.lisp:(defun complexity-strategy (agenda)
environment.lisp:  (defclass exil-environment ()
environment.lisp:  (defvar *environments*
environment.lisp:  (defvar *current-environment*
environment.lisp:(defmacro defenv (name &key (redefine nil))
environment.lisp:(defmacro setenv (name)
environment.lisp:(defmacro exil-env-reader (slot-name)
environment.lisp:	      `(defgeneric ,slot-name ()))
environment.lisp:     (defmethod ,slot-name ()
environment.lisp:(defmacro exil-env-writer (slot-name)
environment.lisp:(defmacro exil-env-accessor (slot-name)
environment.lisp:(defmacro exil-env-accessors (&rest slot-names)
environment.lisp:(defmethod facts (&rest fact-nums)
environment.lisp:(defun add-fact (fact)
environment.lisp:(defun assert% (fact-spec)
environment.lisp:(defun assert-group (fact-descriptions)
environment.lisp:(defun rem-fact (fact)
environment.lisp:(defun retract% (fact-spec)
environment.lisp:(defun modify% (old-fact-spec new-fact-spec)
environment.lisp:(defun add-fact-group (group-name fact-descriptions)
environment.lisp:(defun add-template (template)
environment.lisp:(defmethod find-template (name)
environment.lisp:(defun add-rule (rule)
environment.lisp:(defun rem-rule (rule)
environment.lisp:(defun find-rule (name)
environment.lisp:(defmethod add-match (production token)
environment.lisp:(defmethod remove-match (production token)
environment.lisp:(defmethod remove-matches (rule)
environment.lisp:(defmethod defstrategy% (name function)
environment.lisp:(defmethod set-strategy% (&optional (name 'default))
environment.lisp:(defmethod current-strategy ()
environment.lisp:(defmethod select-activation ()
environment.lisp:(defmethod watch% (watcher)
environment.lisp:(defmethod unwatch% (watcher)
environment.lisp:(defmethod watched-p (watcher)
environment.lisp:(defun reset-environment ()
environment.lisp:(defun completely-reset-environment ()
print-tree.lisp:(defun print-node (node depth &optional (stream t))
print-tree.lisp:(defmethod node-children ((node node))
print-tree.lisp:(defun hash-values (hash-table)
print-tree.lisp:(defmethod node-children ((node alpha-top-node))
print-tree.lisp:(defmethod node-children ((node alpha-test-node))
print-tree.lisp:;(defmethod node-children ((node beta-join-node))
print-tree.lisp:(defun depth-first-search (root function &optional (depth 0))
print-tree.lisp:(defun print-rete (&optional (stream t) (rete (rete)))
export.lisp:(defmacro deftemplate (name fields)
export.lisp:(defmacro assert (&rest fact-specs)
export.lisp:(defmacro retract (fact-spec)
export.lisp:(defmacro modify (old-fact-spec new-fact-spec)
export.lisp:(defun clear ()
export.lisp:(defmacro deffacts (name &body fact-descriptions)
export.lisp:(defun reset ()
export.lisp:(defmacro defrule (name &body rule)
export.lisp:(defmacro undefrule (name)
export.lisp:(defmacro defstrategy (name function)
export.lisp:(defmacro set-strategy (name)
export.lisp:(defun step ()
export.lisp:(defvar *exil-running* nil)
export.lisp:(defun halt ()
export.lisp:(defun run ()
export.lisp:(defmacro watch (watcher)
export.lisp:(defmacro unwatch (watcher)
