\subsubsection{Kompozitní podmínky pravidel}
\label{composite conditions}

Podporu kompozitních podmínek odvozovacích pravidel (vnořené aplikace logických
funkcí v podmínkách) jsem v ExiLu neimplementoval. Rád bych zde ale ukázal, proč
je implementace této funkcionality vzhledem k aktuální implementaci algoritmu
RETE složitá.

\begin{figure}[h]
\centering
\includegraphics[height=10cm]{rete-beta-conds.eps}
\caption{Beta část sítě RETE s funkcemi uzlů}
\label{rete-beta-conds}
\end{figure}

Obrázek \ref{rete-beta-conds} ukazuje diagram beta části sítě RETE z předchozí
kapitoly. Názvy uzlů jsem zde ale nahradil jejich funkcí. Paměťové uzly ukládají
fakty nebo tokeny splňující jednu (v případě alpha-memory-nodů), nebo více (u
beta-memory-nodů) podmínek pravidla. Testovací (beta-join-nody) pak zajišťují
agregaci těchto faktů a tokenů. Jednu z podmínek jsem navíc pro ukázku znegoval.

Síť v diagramu splňuje několik podmínek:
\begin{enumerate}
  \item uzly jsou konstruovány ve stejném pořadí, v jakém se podmínky v definici
    pravidla vyskytují,
  \item beta-join-node vždy spojuje jeden alpha-memory-node s jedním
    beta-memory-nodem, agreguje tedy fakty splňující jednu podmínku pravidla s
    tokeny reprezentujícími posloupnost faktů splňující jeho předchozí podmínky,
  \item negace podmínky je vždy aplikována jen na úrovni jednoho faktu.
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[height=12cm]{rete-beta-comp-conds.eps}
\caption{Síť RETE s kompozitními podmínkami}
\label{rete-beta-comp-conds}
\end{figure}

Představme si nyní stavbu RETE sítě v případě následujícícho pravidla
s~kompozitními podmínkami:
\begin{minted}{cl}
(defrule rule
  (and (or condition1 condition2)
       (not (and condition3 condition4)))
  =>
  ...)
\end{minted}
Ta je zobrazena na obrázku \ref{rete-beta-comp-conds} Z diagramu vidíme, že síť porušuje všechny
uvedené podmínky.

\begin{framed}
  \begin{itemize}
    \item popsat, co je problematického na podpoře této sítě
    \item podmínky třeba procházet rekurzivně a síť budovat stromovitě
    \item token je nyní list, stačí to, nebo musí být také strom?
    \item testy v join nodech nyní ukládají pozici - o kolik podmínek zpět,
      který atom v přechozí, který atom v aktuální
    \item pozice by musela mít u beta-beta joinu minimálně jednu pozici navíc -
      (fakt,atom)-(fakt,atom), pokud by musel být token strom, ještě složitější
    \item lze vyřešit join-nody obecně - beta-beta i beta-alpha, nebo nutné dva
      typy?
    \item jak reprezentovat node, který neguje složenou podmínku?
    \item jak joinovat tokeny, které mohou zahrnovat výsledky negativní podmínky?
    \item síť je cyklická a jako taková špatně vizualizuje
    \item počet uzlů sítě roste velmi rychle $\rightarrow$ mnoho uzlů i při
      několika pravidlech $\rightarrow$ náročné ladění
    \item podpora kompozitních podmínek je navíc problematická vzhledem ke
      zpětné inferenci (ale ta už je stejně omezená) - znamenalo by složené cíle
      (kvůli or, not)
    \item zmínit, jak jednoduchá je implementace, pokud podmínky pracují pouze
      se substitucemi proměnných - bez rete
  \end{itemize}
\end{framed}
% Z fungování beta částí sítě RETE (viz kapitola \ref{rete}) vidíme, že vyhodnocování
% podmínek pravidla je inherentně sekvenční. \verb|Beta-join-nody| zde
% implementují logickou spojku \emph{a} mezi podmínkami pravidla, která je zde
% zleva asociativní.
