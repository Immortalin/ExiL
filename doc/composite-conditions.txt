- negative-join-node ukládá assoc list - (token . matchující wmes)
- když je přidán první matchující wme, inaktivuje děti tokenem
- když je odebrán poslední, aktivuje děti tokenem
- OPRAVIT V TEXTU, tam je psáno, že aktivuje všemi tokeny


- aktuální rete umožňuje pravidla tvaru
(defrule rule
  (and c1
       (and (not c2)
            c3)))
- tomu odpovídá implementace join-nodů
- díky tomu stačí lineární token (ve skutečnosti ani nestačí na negaci - dále)
- dokonce ani nejsou podporovány plně - nelze testovat vazby vůči předchozí
  negované podmínce:
(defrule rule
  (in obj1 ?loc1)
  (- next-to ?loc1 ?loc2) <- ve skutečnosti matchuje (- next-to ?loc1 ?)
  (in obj2 ?loc2)) <- nemá jak testovat vazbu proti předchozí neg. podmínce,
                      protože token nenese dostatečnou informaci
(deffacts world
  (in obj1 a)
  (in obj2 b)
  (next-to a c)) <- zabrání splnění pravidla
=> mezi podmínkami, které sdílejí proměnné, může být jen jedna negativní a musí
   být jako poslední - ověřit


- negativní vnořené podmínky nelze (ani bez rete) implementovat pomocí negativní
  substituce - jak by vznikala? negativní podmínka není spárována s žádným
  konkrétním faktem (chová se jako forall) - má smysl až když jsou všechny
  proměnné, které se v neg. podmínce vyskytují, navázány i v nějaké pozitivní
  podmínce; jak tedy reprezentovat nenavázané proměnné?
- třeba tedy řešit na úrovni Condition#matches při agregaci (= beta-join - test)
- reprezentace testů s negacemi? zatím máme not alpha - beta, co s
  not beta - alpha, not beta - beta, not beta - not beta
- lze řešit obecně?
- co by tedy mělo být výsledkem NotCondition#matches? - jakou informaci potřebuje
  caller/další uzly v síti?
= co vlastně bude dělat jednovstupový not-beta node?
- úprava testu pro podporu OR?

- pročíst kompozitní podmínky v Doorenbosovi


- rete je vlastně chytrý cachovací (memoizační) mechanismus
- rete síť koresponduje se stromem rekurzivního volání #matches na hierarchicky
  uspořádané podmínky, ale memoizuje výsledky volání v jednotlivých větvích
- při změně jsou upozorněny listy stromu a změna se propaguje směrem ke kořeni,
  ale přepočítávány jsou jen výsledky na cestě list-kořen, ostatní větve jsou
  memoizovány
- token je to, co přenáší informaci o dosavadní agregaci dalším uzlům = nahoru
  ve stromu volání - to, co v exil-rete řeší substituce, ty ale nelze použít s
  negací
- jaká struktura je třeba na přenesení veškeré potřebné informace?
- pokud půjde vnořená negace řešit rekurzivně bez toho, aby podmínky výše v
  hierarchii lezly do podmínek níže, půjde řešit i pomocí rete
= lze-li vymyslet strukturu, kterou bude vnořené volání matches vracet, lze
  použít i jako token
- pokud ne, join/test musí mít víc informací o předchozích podmínkách
- např.
  v--- může být tento and vyhodnocen pouze na základě nějakých výsledků
(and (and (not (in box ?loc))      vnořených volání, nebo musí znát jejich
          (in robot ?loc))         strukturu?
     (in box2 ?loc))
- token buď musí být složitější, nebo test chytřejší (mít zakodovánu strukturu
  předchozích podmínek od vytvoření sítě), pak ale duplikace znalosti a výpočtů
  při znovupoužití předchozí části sítě
=> token musí být strom, jinak nevyjádříme pozici faktu spárovaného s podmínkou
- není dokonce nutné obojí? test stejně musí vědět, jak vypadají podmínky, aby
  mohl stromovitý token párovat
- nebo stačí ukládat vnořené logické funkce v tokenu?
- token nemůže plně odpovídat stromu podmínek - např. u or je v tokenu subtoken
  jen pro jednu větev oru
- activate-rule bude taky muset párovat stromovitě

- token je partial match, pokud by byly všechny proměnné navázány, nese
  plnohodnotnou informaci substituce, jinak musí být obecnější

# význam jednotlivých agregačních funkcí ~ typů podmínek ~ typů join uzlů
- single condition (alpha mem) - tuhle podmínku splňují tyto fakty
- and condition (beta and join) - tuhle podmínku splňují tyto ntice faktů -
  spojuje vnořené podmínky - výsledky vždy stejného typu (pokud není vnořený or)
- or condition (beta or join) - tuhle podmínu splňují tyto fakty - sčítá vnořené
  podmínky - výsledky můžou být různých typů
- negace? forall?
- podmínka říká, jaká kombinace faktů musí existovat, matches vrací všechny
  kombinace z w.m., které splňují, uzly aktivují všemi kombinacemi, které
  splňují

- jakmile je vzor zanořen v lichém počtu negací, třeba testovat not exist =
  forall not - ty se blbě reprezentují v tokenu
- různé možnosti zanoření a jejich existenční/forall charakter - na papíře


## teorie
- citovat bakalářku, neopakovat základy, pokud jsou tam probrány dostatečně (to
  je ale nepavděpodobné vzhledem k tomu, že teorie tam má 1.5 strany)
- rychle shrnout nutné základy - vlastnosti ES, odlišnosti od jiných typů sw
  - dopředné vs zpětné řetězení, ...
- pak se zaměřit na formalizaci pojmů z CLIPSovitého ES + teorii vyhodnocování
  podmínek pravidel - mají existenční charakter, negace přináší forall
- definovat základní pojmy
  - pole atomů A
  - fakt jako vektor (nebo zobrazení u strukt, ale zbytečné) nad polem atomů
    - když zvolíme konkrétní délku faktů, pak B = A^n = mna všech faktů
  - pole proměnných V
  - vzor jako vektor nad polem AuV
    - ----------------------------------, pak C = (AuV)^n = mna všech vzorů
  - pracovní paměť = mna faktů M \subs B
- definovat kongruenci vzoru a faktu
  - kongruence jako relace K \subs BxC
  - pokud bychom nestanovili délku faktů a vzorů, pak ke kongruenci přidat
    rovnost délek
- pak rekurentně definovat kongruenci podmínky a tokenu ~ splnění podmínky tokenem
  - prázdná podmínka splněna vždy = (and) = (or) ~ tautologie
  - single cond přes kongruenci vzoru a faktu
  - dál rekurentně přes spojky
    - and - existuje ntice - spojuje vnořené
    - or - existuje a nebo b - sčítá vnořené
    - not - rozepsat varianty - lze definovat obecně?
  - defaultně exists, co s forall?
- strukturální kongruence - relace slabší než kongruence - neřeší vazby
  proměnných
  - kongruenci lze definovat přes strukturální kongruenci + přidat ošetření
    vazeb
=> splnění podmínky v dané množině faktů ~ pravdivost logické formule při
   ohodnocení
- jednoduchá podmínka splněna, pokud \exists kongruentní fakt = fakt \in M
- složená podmínka totéž, ale třeba rekurentně definovat kongruenci
- vztah podmínky a log formule (term?)
- kvantifikátory -> uzavřené / otevřené podmínky - volné proměnné
===> syntax a sémantika podmínek => pravidel => programu
- syntax definována CLIPSem / ExiLem, sémantika zde

- pak definovat funkci, která vrátí všechny fakty z M kongruentní se vzorem
  - přímo přes kongruenci
- pak rekurentně definovat funkci, která vrátí všechny tokeny nad M, které jsou
  kongruentní s podmínkou
  - přes funkce jednotlivých spojek
- pokud půjde plně udělat, promyslet algoritmizaci, pak zobecnění na RETE
- citovat Doorenbose

- kongruence parial matche (tokenu) s částí stromu vzoru
  - nejsou-li navázány všechny proměnné
  - vzor má existenční (příp. forall) charakter, po navázání všech proměnných už
    podmínka říká "existuje taková (konkrétní) ntice faktů"
    jinak "existuje ntice faktů, taková že ..."

- zdroje?
- není v Introduction to ES něco o reprezentac negativní znalosti / exist,
  forall, and, or, ...?
