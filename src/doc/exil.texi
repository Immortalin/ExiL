\input texinfo

@c exil.texi --- Reference manual

@c Commentary:

@c Generated automatically by Declt version 1.0 beta 15 "James T. Kirk"
@c on Sun Dec 23 22:05:00 2012 GMT+1.


@c ====================================================================
@c Header
@c ====================================================================
@c %**start of header
@setfilename exil.info
@settitle The exil Reference Manual
@afourpaper
@c %**end of header



@c ====================================================================
@c Settings
@c ====================================================================
@setchapternewpage odd
@setcontentsaftertitlepage
@documentdescription
The exil Reference Manual, version 0.1.
@end documentdescription



@c ====================================================================
@c New Commands
@c ====================================================================

@c ---------------
@c Indexing macros
@c ---------------

@c Packages
@macro packageindex{name}
@tpindex \name\
@tpindex @r{Package, }\name\
@end macro

@c Systems
@macro systemindex{name}
@tpindex \name\
@tpindex @r{System, }\name\
@end macro

@c Modules
@macro moduleindex{name}
@cindex @t{\name\}
@cindex Module, @t{\name\}
@end macro

@c Lisp files
@macro lispfileindex{name}
@cindex @t{\name\}
@cindex Lisp File, @t{\name\}
@cindex File, Lisp, @t{\name\}
@end macro

@c C files
@macro cfileindex{name}
@cindex @t{\name\}
@cindex C File, @t{\name\}
@cindex File, C, @t{\name\}
@end macro

@c Java files
@macro javafileindex{name}
@cindex @t{\name\}
@cindex Java File, @t{\name\}
@cindex File, Java, @t{\name\}
@end macro

@c Other files
@macro otherfileindex{name}
@cindex @t{\name\}
@cindex Other File, @t{\name\}
@cindex File, other, @t{\name\}
@end macro

@c Doc files
@macro docfileindex{name}
@cindex @t{\name\}
@cindex Doc File, @t{\name\}
@cindex File, doc, @t{\name\}
@end macro

@c HTML files
@macro htmlfileindex{name}
@cindex @t{\name\}
@cindex HTML File, @t{\name\}
@cindex File, html, @t{\name\}
@end macro

@c The following macros are meant to be used within @defxxx environments.
@c Texinfo performs half the indexing job and we do the other half.

@c Constants
@macro constantsubindex{name}
@vindex @r{Constant, }\name\
@end macro

@c Special variables
@macro specialsubindex{name}
@vindex @r{Special Variable, }\name\
@end macro

@c Symbol macros
@macro symbolmacrosubindex{name}
@vindex @r{Symbol Macro, }\name\
@end macro

@c Slots
@macro slotsubindex{name}
@vindex @r{Slot, }\name\
@end macro

@c Macros
@macro macrosubindex{name}
@findex @r{Macro, }\name\
@end macro

@c Compiler Macros
@macro compilermacrosubindex{name}
@findex @r{Compiler Macro, }\name\
@end macro

@c Functions
@macro functionsubindex{name}
@findex @r{Function, }\name\
@end macro

@c Methods
@macro methodsubindex{name}
@findex @r{Method, }\name\
@end macro

@c Generic Functions
@macro genericsubindex{name}
@findex @r{Generic Function, }\name\
@end macro

@c Conditions
@macro conditionsubindex{name}
@tpindex @r{Condition, }\name\
@end macro

@c Structures
@macro structuresubindex{name}
@tpindex @r{Structure, }\name\
@end macro

@c Classes
@macro classsubindex{name}
@tpindex @r{Class, }\name\
@end macro



@c ====================================================================
@c Info Category and Directory
@c ====================================================================
@dircategory Common Lisp
@direntry
* exil Reference: (exil). The exil Reference Manual.
@end direntry



@c ====================================================================
@c Title Page
@c ====================================================================
@titlepage
@title The exil Reference Manual
@subtitle EXpert system In Lisp, version 0.1
@author Jakub Kalab <@email{jakubkalab@@gmail.com}>

@page
@quotation
This manual was generated automatically by Declt 1.0 beta 15 "James T. Kirk" on Sun Dec 23 22:05:00 2012 GMT+1.
@end quotation
@end titlepage



@c ====================================================================
@c Table of Contents
@c ====================================================================
@contents



@c ====================================================================
@c Top
@c ====================================================================
@ifnottex
@node Top, System, (dir), (dir)
@top The exil Reference Manual

This is the exil Reference Manual, version 0.1,
generated automatically by Declt version 1.0 beta 15 "James T. Kirk"
on Sun Dec 23 22:05:00 2012 GMT+1.

@menu
* System:: The system documentation
* Files:: The files documentation
* Packages:: The packages documentation
* Definitions:: The symbols documentation
* Indexes:: Concepts, functions, variables and data types
@end menu
@end ifnottex



@c ====================================================================
@c System
@c ====================================================================
@node System, Files, Top, Top
@chapter System

@anchor{go to the exil system}@c
@systemindex{exil}@c
@table @strong
@item Name
@t{exil}
@item Author
Jakub Kalab <@email{jakubkalab@@gmail.com}>
@item Maintainer
Jakub Kalab <@email{jakubkalab@@gmail.com}>
@item License
BSD
@item Description
EXpert system In Lisp
@item Long Description
@item Version
0.1
@item Definition file
@ref{go to the exil.asd file, , @t{exil.asd}} (Lisp file)
@item Components
@itemize @bullet
@item
@ref{go to the packages.lisp file, , @t{packages}} (Lisp file)
@item
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@item
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@item
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@item
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@item
@ref{go to the rules.lisp file, , @t{rules}} (Lisp file)
@item
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@item
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@item
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@item
@ref{go to the matches.lisp file, , @t{matches}} (Lisp file)
@item
@ref{go to the activations.lisp file, , @t{activations}} (Lisp file)
@item
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@item
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@item
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end itemize
@end table



@c ====================================================================
@c Files
@c ====================================================================
@node Files, Packages, System, Top
@chapter Files

Files are sorted by type and then listed depth-first from the system
components tree.

@menu
* Lisp files::
@end menu


@c ----------
@c Lisp files
@c ----------
@node Lisp files, , Files, Files
@section Lisp

@menu
* The exil.asd file::
* The packages.lisp file::
* The utils.lisp file::
* The templates.lisp file::
* The facts.lisp file::
* The patterns.lisp file::
* The rules.lisp file::
* The tokens.lisp file::
* The rete-generic-node.lisp file::
* The rete-alpha-part.lisp file::
* The rete-beta-part.lisp file::
* The rete-net-creation.lisp file::
* The matches.lisp file::
* The activations.lisp file::
* The strategies.lisp file::
* The environment.lisp file::
* The export.lisp file::
@end menu

@node The exil.asd file, The packages.lisp file, Lisp files, Lisp files
@subsection @t{exil.asd}

@anchor{go to the exil.asd file}@c
@lispfileindex{exil.asd}@c
@table @strong
@item Location
@t{exil.asd}
@item Packages
@ref{go to the exil-system package, , @t{exil-system}}
@end table

@node The packages.lisp file, The utils.lisp file, The exil.asd file, Lisp files
@subsection @t{packages.lisp}

@anchor{go to the packages.lisp file}@c
@lispfileindex{packages.lisp}@c
@table @strong
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{packages.lisp}
@item Packages
@itemize @bullet
@item
@ref{go to the exil-utils package, , @t{exil-utils}}
@item
@ref{go to the exil-core package, , @t{exil-core}}
@item
@ref{go to the exil-rete package, , @t{exil-rete}}
@item
@ref{go to the exil-env package, , @t{exil-env}}
@item
@ref{go to the exil package, , @t{exil}}
@item
@ref{go to the exil-user package, , @t{exil-user}}
@end itemize
@end table

@node The utils.lisp file, The templates.lisp file, The packages.lisp file, Lisp files
@subsection @t{utils.lisp}

@anchor{go to the utils.lisp file}@c
@lispfileindex{utils.lisp}@c
@table @strong
@item Dependency
@t{packages}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{utils.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the alistp function, , @t{alistp}} (function)
@item
@ref{go to the assoc-key function, , @t{assoc-key}} (function)
@item
@ref{go to the assoc-value function, , @t{assoc-value}} (function)
@item
@ref{go to the (setf assoc-value) function, , @t{(setf assoc-value)}} (function)
@item
@ref{go to the class-slot-value function, , @t{class-slot-value}} (function)
@item
@ref{go to the cpl-assoc-val function, , @t{cpl-assoc-val}} (function)
@item
@ref{go to the (setf cpl-assoc-val) function, , @t{(setf cpl-assoc-val)}} (function)
@item
@ref{go to the diff-delete macro, , @t{diff-delete}} (macro)
@item
@ref{go to the doplist macro, , @t{doplist}} (macro)
@item
@ref{go to the every-couple function, , @t{every-couple}} (function)
@item
@ref{go to the exil-equal-p generic function, , @t{exil-equal-p}} (generic function)
@item
@ref{go to the exil-equal-p cons cons method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p number number method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p symbol symbol method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p string string method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p t t method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p null null method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-weak-equal-p generic function, , @t{exil-weak-equal-p}} (generic function)
@item
@ref{go to the exil-weak-equal-p cons cons method, , @t{exil-weak-equal-p}} (method)
@item
@ref{go to the exil-weak-equal-p symbol symbol method, , @t{exil-weak-equal-p}} (method)
@item
@ref{go to the exil-weak-equal-p t t method, , @t{exil-weak-equal-p}} (method)
@item
@ref{go to the ext-delete macro, , @t{ext-delete}} (macro)
@item
@ref{go to the ext-pushnew macro, , @t{ext-pushnew}} (macro)
@item
@ref{go to the from-keyword function, , @t{from-keyword}} (function)
@item
@ref{go to the hash->list hash-table method, , @t{hash->list}} (method)
@item
@ref{go to the intern function, , @t{intern}} (function)
@item
@ref{go to the mac-exp macro, , @t{mac-exp}} (macro)
@item
@ref{go to the plistp function, , @t{plistp}} (function)
@item
@ref{go to the push-end macro, , @t{push-end}} (macro)
@item
@ref{go to the push-update macro, , @t{push-update}} (macro)
@item
@ref{go to the pushnew-end macro, , @t{pushnew-end}} (macro)
@item
@ref{go to the select function, , @t{select}} (function)
@item
@ref{go to the string-append function, , @t{string-append}} (function)
@item
@ref{go to the subsets function, , @t{subsets}} (function)
@item
@ref{go to the symbol-append function, , @t{symbol-append}} (function)
@item
@ref{go to the symbol-name generic function, , @t{symbol-name}} (generic function)
@item
@ref{go to the symbol-name symbol method, , @t{symbol-name}} (method)
@item
@ref{go to the symbol-name string method, , @t{symbol-name}} (method)
@item
@ref{go to the to-keyword function, , @t{to-keyword}} (function)
@item
@ref{go to the to-list function, , @t{to-list}} (function)
@item
@ref{go to the to-list-of-lists function, , @t{to-list-of-lists}} (function)
@item
@ref{go to the weak-symbol-equal-p generic function, , @t{weak-symbol-equal-p}} (generic function)
@item
@ref{go to the weak-symbol-equal-p symbol symbol method, , @t{weak-symbol-equal-p}} (method)
@item
@ref{go to the weak-symbol-equal-p t t method, , @t{weak-symbol-equal-p}} (method)
@end itemize
@end table

@node The templates.lisp file, The facts.lisp file, The utils.lisp file, Lisp files
@subsection @t{templates.lisp}

@anchor{go to the templates.lisp file}@c
@lispfileindex{templates.lisp}@c
@table @strong
@item Dependency
@t{utils}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{templates.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the atom-position template-object t method, , @t{atom-position}} (method)
@item
@ref{go to the find-atom template-object t method, , @t{find-atom}} (method)
@item
@ref{go to the has-slot-p template-object t method, , @t{has-slot-p}} (method)
@item
@ref{go to the make-template function, , @t{make-template}} (function)
@item
@ref{go to the name template method, , @t{name}} (method)
@item
@ref{go to the slots template-object method, , @t{slots}} (method)
@item
@ref{go to the slots template method, , @t{slots}} (method)
@item
@ref{go to the template class, , @t{template}} (class)
@item
@ref{go to the tmpl-name template-object method, , @t{tmpl-name}} (method)
@item
@ref{go to the variable-p function, , @t{variable-p}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the clips-tmpl-slot-spec-p function, , @t{clips-tmpl-slot-spec-p}} (function)
@item
@ref{go to the make-tmpl-obj-clips function, , @t{make-tmpl-obj-clips}} (function)
@item
@ref{go to the make-tmpl-obj-nonclips function, , @t{make-tmpl-obj-nonclips}} (function)
@item
@ref{go to the make-tmpl-object function, , @t{make-tmpl-object}} (function)
@item
@ref{go to the template-object class, , @t{template-object}} (class)
@item
@ref{go to the tmpl-object-equal-p template-object template-object method, , @t{tmpl-object-equal-p}} (method)
@item
@ref{go to the tmpl-object-slot-value template-object t method, , @t{tmpl-object-slot-value}} (method)
@item
@ref{go to the (setf tmpl-object-slot-value) t template-object t method, , @t{(setf tmpl-object-slot-value)}} (method)
@item
@ref{go to the tmpl-object-specification-p function, , @t{tmpl-object-specification-p}} (function)
@item
@ref{go to the tmpl-slot-spec-p function, , @t{tmpl-slot-spec-p}} (function)
@end itemize
@end table

@node The facts.lisp file, The patterns.lisp file, The templates.lisp file, Lisp files
@subsection @t{facts.lisp}

@anchor{go to the facts.lisp file}@c
@lispfileindex{facts.lisp}@c
@table @strong
@item Dependency
@t{templates}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{facts.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the atom-position simple-fact t method, , @t{atom-position}} (method)
@item
@ref{go to the copy-fact fact method, , @t{copy-fact}} (method)
@item
@ref{go to the fact simple-fact method, , @t{fact}} (method)
@item
@ref{go to the fact class, , @t{fact}} (class)
@item
@ref{go to the fact-description template-fact method, , @t{fact-description}} (method)
@item
@ref{go to the fact-description simple-fact method, , @t{fact-description}} (method)
@item
@ref{go to the fact-equal-p generic function, , @t{fact-equal-p}} (generic function)
@item
@ref{go to the fact-equal-p template-fact template-fact method, , @t{fact-equal-p}} (method)
@item
@ref{go to the fact-equal-p simple-fact simple-fact method, , @t{fact-equal-p}} (method)
@item
@ref{go to the fact-equal-p t t method, , @t{fact-equal-p}} (method)
@item
@ref{go to the fact-slot generic function, , @t{fact-slot}} (generic function)
@item
@ref{go to the fact-slot simple-fact integer method, , @t{fact-slot}} (method)
@item
@ref{go to the fact-slot template-fact symbol method, , @t{fact-slot}} (method)
@item
@ref{go to the find-atom simple-fact t method, , @t{find-atom}} (method)
@item
@ref{go to the make-fact function, , @t{make-fact}} (function)
@item
@ref{go to the simple-fact class, , @t{simple-fact}} (class)
@item
@ref{go to the template-fact class, , @t{template-fact}} (class)
@item
@ref{go to the tmpl-fact-slot-value template-fact t method, , @t{tmpl-fact-slot-value}} (method)
@item
@ref{go to the (setf tmpl-fact-slot-value) t template-fact t method, , @t{(setf tmpl-fact-slot-value)}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the make-tmpl-fact function, , @t{make-tmpl-fact}} (function)
@item
@ref{go to the tmpl-fact-specification-p function, , @t{tmpl-fact-specification-p}} (function)
@end itemize
@end table

@node The patterns.lisp file, The rules.lisp file, The facts.lisp file, Lisp files
@subsection @t{patterns.lisp}

@anchor{go to the patterns.lisp file}@c
@lispfileindex{patterns.lisp}@c
@table @strong
@item Dependency
@t{facts}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{patterns.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the atom-equal-p generic function, , @t{atom-equal-p}} (generic function)
@item
@ref{go to the atom-equal-p t t method, , @t{atom-equal-p}} (method)
@item
@ref{go to the atom-position simple-pattern t method, , @t{atom-position}} (method)
@item
@ref{go to the constant-test function, , @t{constant-test}} (function)
@item
@ref{go to the find-atom simple-pattern t method, , @t{find-atom}} (method)
@item
@ref{go to the make-pattern function, , @t{make-pattern}} (function)
@item
@ref{go to the match-var pattern method, , @t{match-var}} (method)
@item
@ref{go to the (setf match-var) t pattern method, , @t{(setf match-var)}} (method)
@item
@ref{go to the negated-p pattern method, , @t{negated-p}} (method)
@item
@ref{go to the (setf negated-p) t pattern method, , @t{(setf negated-p)}} (method)
@item
@ref{go to the pattern simple-pattern method, , @t{pattern}} (method)
@item
@ref{go to the pattern class, , @t{pattern}} (class)
@item
@ref{go to the pattern-equal-p generic function, , @t{pattern-equal-p}} (generic function)
@item
@ref{go to the pattern-equal-p template-pattern template-pattern method, , @t{pattern-equal-p}} (method)
@item
@ref{go to the pattern-equal-p simple-pattern simple-pattern method, , @t{pattern-equal-p}} (method)
@item
@ref{go to the pattern-equal-p pattern pattern method, , @t{pattern-equal-p}} (method)
@item
@ref{go to the simple-pattern class, , @t{simple-pattern}} (class)
@item
@ref{go to the template-pattern class, , @t{template-pattern}} (class)
@item
@ref{go to the var-or-equal-p function, , @t{var-or-equal-p}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the make-tmpl-pattern function, , @t{make-tmpl-pattern}} (function)
@item
@ref{go to the tmpl-pattern-slot-value template-pattern t method, , @t{tmpl-pattern-slot-value}} (method)
@item
@ref{go to the tmpl-pattern-specification-p function, , @t{tmpl-pattern-specification-p}} (function)
@end itemize
@end table

@node The rules.lisp file, The tokens.lisp file, The patterns.lisp file, Lisp files
@subsection @t{rules.lisp}

@anchor{go to the rules.lisp file}@c
@lispfileindex{rules.lisp}@c
@table @strong
@item Dependency
@t{patterns}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{rules.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the activations rule method, , @t{activations}} (method)
@item
@ref{go to the conditions rule method, , @t{conditions}} (method)
@item
@ref{go to the make-rule t t t method, , @t{make-rule}} (method)
@item
@ref{go to the name rule method, , @t{name}} (method)
@item
@ref{go to the rule class, , @t{rule}} (class)
@item
@ref{go to the rule-equal-p rule rule method, , @t{rule-equal-p}} (method)
@end itemize
@end table

@node The tokens.lisp file, The rete-generic-node.lisp file, The rules.lisp file, Lisp files
@subsection @t{tokens.lisp}

@anchor{go to the tokens.lisp file}@c
@lispfileindex{tokens.lisp}@c
@table @strong
@item Dependency
@t{rules}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{tokens.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the token->list token method, , @t{token->list}} (method)
@item
@ref{go to the token-equal-p generic function, , @t{token-equal-p}} (generic function)
@item
@ref{go to the token-equal-p t t method, , @t{token-equal-p}} (method)
@item
@ref{go to the token-equal-p empty-token empty-token method, , @t{token-equal-p}} (method)
@item
@ref{go to the token-equal-p token token method, , @t{token-equal-p}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the empty-token class, , @t{empty-token}} (class)
@item
@ref{go to the includes-p token token method, , @t{includes-p}} (method)
@item
@ref{go to the includes-p fact token method, , @t{includes-p}} (method)
@item
@ref{go to the negative-wmes token method, , @t{negative-wmes}} (method)
@item
@ref{go to the (setf negative-wmes) t token method, , @t{(setf negative-wmes)}} (method)
@item
@ref{go to the parent token method, , @t{parent}} (method)
@item
@ref{go to the previous-wme token method, , @t{previous-wme}} (method)
@item
@ref{go to the token t method, , @t{token}} (method)
@item
@ref{go to the token class, , @t{token}} (class)
@item
@ref{go to the wme token method, , @t{wme}} (method)
@end itemize
@end table

@node The rete-generic-node.lisp file, The rete-alpha-part.lisp file, The tokens.lisp file, Lisp files
@subsection @t{rete-generic-node.lisp}

@anchor{go to the rete-generic-node.lisp file}@c
@lispfileindex{rete-generic-node.lisp}@c
@table @strong
@item Dependency
@t{tokens}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{rete-generic-node.lisp}
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the activate generic function, , @t{activate}} (generic function)
@item
@ref{go to the activate-children generic function, , @t{activate-children}} (generic function)
@item
@ref{go to the activate-children node t method, , @t{activate-children}} (method)
@item
@ref{go to the add-child node node method, , @t{add-child}} (method)
@item
@ref{go to the add-children node list method, , @t{add-children}} (method)
@item
@ref{go to the add-item memory-node t method, , @t{add-item}} (method)
@item
@ref{go to the children node method, , @t{children}} (method)
@item
@ref{go to the (setf children) t node method, , @t{(setf children)}} (method)
@item
@ref{go to the described-object class, , @t{described-object}} (class)
@item
@ref{go to the description described-object method, , @t{description}} (method)
@item
@ref{go to the (setf description) t described-object method, , @t{(setf description)}} (method)
@item
@ref{go to the inactivate generic function, , @t{inactivate}} (generic function)
@item
@ref{go to the inactivate node t method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate-children node t method, , @t{inactivate-children}} (method)
@item
@ref{go to the items memory-node method, , @t{items}} (method)
@item
@ref{go to the (setf items) t memory-node method, , @t{(setf items)}} (method)
@item
@ref{go to the memory-node class, , @t{memory-node}} (class)
@item
@ref{go to the node class, , @t{node}} (class)
@item
@ref{go to the node-equal-p generic function, , @t{node-equal-p}} (generic function)
@item
@ref{go to the node-equal-p (eql nil) (eql nil) method, , @t{node-equal-p}} (method)
@item
@ref{go to the node-equal-p node node method, , @t{node-equal-p}} (method)
@end itemize
@end table

@node The rete-alpha-part.lisp file, The rete-beta-part.lisp file, The rete-generic-node.lisp file, Lisp files
@subsection @t{rete-alpha-part.lisp}

@anchor{go to the rete-alpha-part.lisp file}@c
@lispfileindex{rete-alpha-part.lisp}@c
@table @strong
@item Dependency
@t{rete-generic-node}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{rete-alpha-part.lisp}
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the activate alpha-memory-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-top-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-subtop-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-test-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate-children alpha-test-node fact method, , @t{activate-children}} (method)
@item
@ref{go to the activate-memory alpha-test-node fact method, , @t{activate-memory}} (method)
@item
@ref{go to the alpha-memory-node class, , @t{alpha-memory-node}} (class)
@item
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item
@ref{go to the alpha-subtop-node class, , @t{alpha-subtop-node}} (class)
@item
@ref{go to the alpha-test-node class, , @t{alpha-test-node}} (class)
@item
@ref{go to the alpha-top-node class, , @t{alpha-top-node}} (class)
@item
@ref{go to the get-network alpha-top-node method, , @t{get-network}} (method)
@item
@ref{go to the (setf get-network) t alpha-top-node method, , @t{(setf get-network)}} (method)
@item
@ref{go to the get/initialize-network alpha-top-node method, , @t{get/initialize-network}} (method)
@item
@ref{go to the inactivate alpha-memory-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate alpha-top-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate alpha-test-node fact after method, , @t{inactivate}} (method)
@item
@ref{go to the initialize-network alpha-top-node method, , @t{initialize-network}} (method)
@item
@ref{go to the memory alpha-test-node method, , @t{memory}} (method)
@item
@ref{go to the (setf memory) t alpha-test-node method, , @t{(setf memory)}} (method)
@item
@ref{go to the networks alpha-top-node method, , @t{networks}} (method)
@item
@ref{go to the (setf networks) t alpha-top-node method, , @t{(setf networks)}} (method)
@item
@ref{go to the node-equal-p alpha-test-node alpha-test-node method, , @t{node-equal-p}} (method)
@item
@ref{go to the simple-fact-alpha-node class, , @t{simple-fact-alpha-node}} (class)
@item
@ref{go to the simple-fact-key-name alpha-top-node method, , @t{simple-fact-key-name}} (method)
@item
@ref{go to the simple-fact-subtop-node class, , @t{simple-fact-subtop-node}} (class)
@item
@ref{go to the simple-fact-test-node class, , @t{simple-fact-test-node}} (class)
@item
@ref{go to the template-fact-alpha-node class, , @t{template-fact-alpha-node}} (class)
@item
@ref{go to the template-fact-subtop-node class, , @t{template-fact-subtop-node}} (class)
@item
@ref{go to the template-fact-test-node class, , @t{template-fact-test-node}} (class)
@item
@ref{go to the test generic function, , @t{test}} (generic function)
@item
@ref{go to the test template-fact-test-node template-fact method, , @t{test}} (method)
@item
@ref{go to the test simple-fact-test-node simple-fact method, , @t{test}} (method)
@item
@ref{go to the test alpha-test-node fact method, , @t{test}} (method)
@item
@ref{go to the tested-field alpha-test-node method, , @t{tested-field}} (method)
@item
@ref{go to the value alpha-test-node method, , @t{value}} (method)
@end itemize
@end table

@node The rete-beta-part.lisp file, The rete-net-creation.lisp file, The rete-alpha-part.lisp file, Lisp files
@subsection @t{rete-beta-part.lisp}

@anchor{go to the rete-beta-part.lisp file}@c
@lispfileindex{rete-beta-part.lisp}@c
@table @strong
@item Dependency
@t{rete-alpha-part}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{rete-beta-part.lisp}
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the activate beta-negative-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate beta-negative-node token method, , @t{activate}} (method)
@item
@ref{go to the activate beta-join-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate beta-join-node token method, , @t{activate}} (method)
@item
@ref{go to the activate beta-memory-node token method, , @t{activate}} (method)
@item
@ref{go to the add-production beta-memory-node rule method, , @t{add-production}} (method)
@item
@ref{go to the alpha-memory beta-join-node method, , @t{alpha-memory}} (method)
@item
@ref{go to the beta-join-node class, , @t{beta-join-node}} (class)
@item
@ref{go to the beta-memory beta-join-node method, , @t{beta-memory}} (method)
@item
@ref{go to the beta-memory-node class, , @t{beta-memory-node}} (class)
@item
@ref{go to the beta-negative-node class, , @t{beta-negative-node}} (class)
@item
@ref{go to the beta-node class, , @t{beta-node}} (class)
@item
@ref{go to the beta-top-node class, , @t{beta-top-node}} (class)
@item
@ref{go to the broken-match beta-memory-node token method, , @t{broken-match}} (method)
@item
@ref{go to the complete-match beta-memory-node token method, , @t{complete-match}} (method)
@item
@ref{go to the current-field test method, , @t{current-field}} (method)
@item
@ref{go to the delete-production beta-memory-node rule method, , @t{delete-production}} (method)
@item
@ref{go to the get-bad-wmes beta-negative-node token method, , @t{get-bad-wmes}} (method)
@item
@ref{go to the inactivate beta-negative-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate beta-memory-node token before method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate beta-memory-node fact before method, , @t{inactivate}} (method)
@item
@ref{go to the make-test function, , @t{make-test}} (function)
@item
@ref{go to the node-equal-p beta-join-node beta-join-node method, , @t{node-equal-p}} (method)
@item
@ref{go to the parent beta-node method, , @t{parent}} (method)
@item
@ref{go to the (setf parent) t beta-node method, , @t{(setf parent)}} (method)
@item
@ref{go to the perform-join-test test token fact method, , @t{perform-join-test}} (method)
@item
@ref{go to the perform-join-tests list token fact method, , @t{perform-join-tests}} (method)
@item
@ref{go to the previous-condition test method, , @t{previous-condition}} (method)
@item
@ref{go to the previous-field test method, , @t{previous-field}} (method)
@item
@ref{go to the productions beta-memory-node method, , @t{productions}} (method)
@item
@ref{go to the (setf productions) t beta-memory-node method, , @t{(setf productions)}} (method)
@item
@ref{go to the test class, , @t{test}} (class)
@item
@ref{go to the test-equal-p test test method, , @t{test-equal-p}} (method)
@item
@ref{go to the tests beta-join-node method, , @t{tests}} (method)
@item
@ref{go to the (setf tests) t beta-join-node method, , @t{(setf tests)}} (method)
@item
@ref{go to the tests-equal-p list list method, , @t{tests-equal-p}} (method)
@end itemize
@end table

@node The rete-net-creation.lisp file, The matches.lisp file, The rete-beta-part.lisp file, Lisp files
@subsection @t{rete-net-creation.lisp}

@anchor{go to the rete-net-creation.lisp file}@c
@lispfileindex{rete-net-creation.lisp}@c
@table @strong
@item Dependency
@t{rete-beta-part}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{rete-net-creation.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the add-wme fact method, , @t{add-wme}} (method)
@item
@ref{go to the make-rete function, , @t{make-rete}} (function)
@item
@ref{go to the new-production rule method, , @t{new-production}} (method)
@item
@ref{go to the rem-wme fact method, , @t{rem-wme}} (method)
@item
@ref{go to the remove-production rule method, , @t{remove-production}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the alpha-top-node rete method, , @t{alpha-top-node}} (method)
@item
@ref{go to the beta-top-node rete method, , @t{beta-top-node}} (method)
@item
@ref{go to the (setf beta-top-node) t rete method, , @t{(setf beta-top-node)}} (method)
@item
@ref{go to the create-alpha-net template-pattern method, , @t{create-alpha-net}} (method)
@item
@ref{go to the create-alpha-net simple-pattern method, , @t{create-alpha-net}} (method)
@item
@ref{go to the create-alpha-net% template-pattern template-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@item
@ref{go to the create-alpha-net% simple-pattern simple-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@item
@ref{go to the find-atom-in-cond-list% function, , @t{find-atom-in-cond-list%}} (function)
@item
@ref{go to the find-test-node alpha-node t t method, , @t{find-test-node}} (method)
@item
@ref{go to the find/create-join-node beta-memory-node list alpha-memory-node method, , @t{find/create-join-node}} (method)
@item
@ref{go to the find/create-neg-node beta-memory-node list alpha-memory-node method, , @t{find/create-neg-node}} (method)
@item
@ref{go to the find/create-test-node generic function, , @t{find/create-test-node}} (generic function)
@item
@ref{go to the find/create-test-node simple-fact-alpha-node t t method, , @t{find/create-test-node}} (method)
@item
@ref{go to the find/create-test-node template-fact-alpha-node t t method, , @t{find/create-test-node}} (method)
@item
@ref{go to the find/create-test-node% t t t t method, , @t{find/create-test-node%}} (method)
@item
@ref{go to the get-intercondition-tests% template-pattern list method, , @t{get-intercondition-tests%}} (method)
@item
@ref{go to the get-intercondition-tests% simple-pattern list method, , @t{get-intercondition-tests%}} (method)
@item
@ref{go to the get-intracondition-tests% template-pattern method, , @t{get-intracondition-tests%}} (method)
@item
@ref{go to the get-intracondition-tests% simple-pattern method, , @t{get-intracondition-tests%}} (method)
@item
@ref{go to the get-join-tests-from-condition pattern list method, , @t{get-join-tests-from-condition}} (method)
@item
@ref{go to the rete class, , @t{rete}} (class)
@end itemize
@end table

@node The matches.lisp file, The activations.lisp file, The rete-net-creation.lisp file, Lisp files
@subsection @t{matches.lisp}

@anchor{go to the matches.lisp file}@c
@lispfileindex{matches.lisp}@c
@table @strong
@item Dependency
@t{rete-net-creation}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{matches.lisp}
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the make-match function, , @t{make-match}} (function)
@item
@ref{go to the match class, , @t{match}} (class)
@item
@ref{go to the match-equal-p match match method, , @t{match-equal-p}} (method)
@item
@ref{go to the match-rule match method, , @t{match-rule}} (method)
@item
@ref{go to the match-token match method, , @t{match-token}} (method)
@item
@ref{go to the timestamp match method, , @t{timestamp}} (method)
@end itemize
@end table

@node The activations.lisp file, The strategies.lisp file, The matches.lisp file, Lisp files
@subsection @t{activations.lisp}

@anchor{go to the activations.lisp file}@c
@lispfileindex{activations.lisp}@c
@table @strong
@item Dependency
@t{matches}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{activations.lisp}
@item Exported Definitions
@ref{go to the activate-rule match method, , @t{activate-rule}} (method)
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the get-variable-bindings function, , @t{get-variable-bindings}} (function)
@item
@ref{go to the substitute-variables function, , @t{substitute-variables}} (function)
@item
@ref{go to the variable-bindings template-pattern template-fact method, , @t{variable-bindings}} (method)
@item
@ref{go to the variable-bindings simple-pattern simple-fact method, , @t{variable-bindings}} (method)
@end itemize
@end table

@node The strategies.lisp file, The environment.lisp file, The activations.lisp file, Lisp files
@subsection @t{strategies.lisp}

@anchor{go to the strategies.lisp file}@c
@lispfileindex{strategies.lisp}@c
@table @strong
@item Dependency
@t{activations}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{strategies.lisp}
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the breadth-strategy function, , @t{breadth-strategy}} (function)
@item
@ref{go to the complexity-strategy function, , @t{complexity-strategy}} (function)
@item
@ref{go to the depth-strategy function, , @t{depth-strategy}} (function)
@item
@ref{go to the newer-than match match method, , @t{newer-than}} (method)
@item
@ref{go to the simpler-than match match method, , @t{simpler-than}} (method)
@item
@ref{go to the simpler-than rule rule method, , @t{simpler-than}} (method)
@item
@ref{go to the simplicity-strategy function, , @t{simplicity-strategy}} (function)
@end itemize
@end table

@node The environment.lisp file, The export.lisp file, The strategies.lisp file, Lisp files
@subsection @t{environment.lisp}

@anchor{go to the environment.lisp file}@c
@lispfileindex{environment.lisp}@c
@table @strong
@item Dependency
@t{strategies}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{environment.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the add-fact function, , @t{add-fact}} (function)
@item
@ref{go to the add-fact-group function, , @t{add-fact-group}} (function)
@item
@ref{go to the add-match t t method, , @t{add-match}} (method)
@item
@ref{go to the add-rule function, , @t{add-rule}} (function)
@item
@ref{go to the add-strategy t t method, , @t{add-strategy}} (method)
@item
@ref{go to the add-template function, , @t{add-template}} (function)
@item
@ref{go to the agenda method, , @t{agenda}} (method)
@item
@ref{go to the fact-groups method, , @t{fact-groups}} (method)
@item
@ref{go to the facts method, , @t{facts}} (method)
@item
@ref{go to the find-fact function, , @t{find-fact}} (function)
@item
@ref{go to the find-rule function, , @t{find-rule}} (function)
@item
@ref{go to the find-template t method, , @t{find-template}} (method)
@item
@ref{go to the modify-fact function, , @t{modify-fact}} (function)
@item
@ref{go to the rem-fact function, , @t{rem-fact}} (function)
@item
@ref{go to the rem-fact-group function, , @t{rem-fact-group}} (function)
@item
@ref{go to the rem-rule function, , @t{rem-rule}} (function)
@item
@ref{go to the remove-match t t method, , @t{remove-match}} (method)
@item
@ref{go to the reset-environment function, , @t{reset-environment}} (function)
@item
@ref{go to the reset-facts function, , @t{reset-facts}} (function)
@item
@ref{go to the rete method, , @t{rete}} (method)
@item
@ref{go to the rules method, , @t{rules}} (method)
@item
@ref{go to the select-activation method, , @t{select-activation}} (method)
@item
@ref{go to the set-strategy method, , @t{set-strategy}} (method)
@item
@ref{go to the set-watcher t method, , @t{set-watcher}} (method)
@item
@ref{go to the templates method, , @t{templates}} (method)
@item
@ref{go to the unset-watcher t method, , @t{unset-watcher}} (method)
@item
@ref{go to the unwatch-all method, , @t{unwatch-all}} (method)
@item
@ref{go to the watch-all method, , @t{watch-all}} (method)
@item
@ref{go to the watched-p t method, , @t{watched-p}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the *current-environment* special variable, , @t{*current-environment*}} (special variable)
@item
@ref{go to the *environments* special variable, , @t{*environments*}} (special variable)
@item
@ref{go to the completely-reset-environment function, , @t{completely-reset-environment}} (function)
@item
@ref{go to the current-strategy method, , @t{current-strategy}} (method)
@item
@ref{go to the current-strategy-name method, , @t{current-strategy-name}} (method)
@item
@ref{go to the defenv macro, , @t{defenv}} (macro)
@item
@ref{go to the exil-env-accessor macro, , @t{exil-env-accessor}} (macro)
@item
@ref{go to the exil-env-accessors macro, , @t{exil-env-accessors}} (macro)
@item
@ref{go to the exil-env-reader macro, , @t{exil-env-reader}} (macro)
@item
@ref{go to the exil-env-writer macro, , @t{exil-env-writer}} (macro)
@item
@ref{go to the exil-environment class, , @t{exil-environment}} (class)
@item
@ref{go to the is-watcher symbol method, , @t{is-watcher}} (method)
@item
@ref{go to the remove-matches t method, , @t{remove-matches}} (method)
@item
@ref{go to the setenv macro, , @t{setenv}} (macro)
@item
@ref{go to the strategies method, , @t{strategies}} (method)
@item
@ref{go to the watchers method, , @t{watchers}} (method)
@end itemize
@end table

@node The export.lisp file, , The environment.lisp file, Lisp files
@subsection @t{export.lisp}

@anchor{go to the export.lisp file}@c
@lispfileindex{export.lisp}@c
@table @strong
@item Dependency
@t{environment}
@item Parent
@ref{go to the exil system, , @t{exil}} (system)
@item Location
@t{export.lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the assert macro, , @t{assert}} (macro)
@item
@ref{go to the clear function, , @t{clear}} (function)
@item
@ref{go to the deffacts macro, , @t{deffacts}} (macro)
@item
@ref{go to the defrule macro, , @t{defrule}} (macro)
@item
@ref{go to the defstrategy macro, , @t{defstrategy}} (macro)
@item
@ref{go to the deftemplate macro, , @t{deftemplate}} (macro)
@item
@ref{go to the facts function, , @t{facts}} (function)
@item
@ref{go to the halt function, , @t{halt}} (function)
@item
@ref{go to the modify macro, , @t{modify}} (macro)
@item
@ref{go to the ppdefrule macro, , @t{ppdefrule}} (macro)
@item
@ref{go to the reset function, , @t{reset}} (function)
@item
@ref{go to the retract macro, , @t{retract}} (macro)
@item
@ref{go to the retract-all function, , @t{retract-all}} (function)
@item
@ref{go to the run function, , @t{run}} (function)
@item
@ref{go to the setstrategy macro, , @t{setstrategy}} (macro)
@item
@ref{go to the step function, , @t{step}} (function)
@item
@ref{go to the undeffacts macro, , @t{undeffacts}} (macro)
@item
@ref{go to the undefrule macro, , @t{undefrule}} (macro)
@item
@ref{go to the unwatch macro, , @t{unwatch}} (macro)
@item
@ref{go to the watch macro, , @t{watch}} (macro)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the *clips-mode* special variable, , @t{*clips-mode*}} (special variable)
@item
@ref{go to the *exil-running* special variable, , @t{*exil-running*}} (special variable)
@item
@ref{go to the assert% function, , @t{assert%}} (function)
@item
@ref{go to the assert-group% function, , @t{assert-group%}} (function)
@item
@ref{go to the clips->nonclips-mod-list function, , @t{clips->nonclips-mod-list}} (function)
@item
@ref{go to the clips-mod-list-p function, , @t{clips-mod-list-p}} (function)
@item
@ref{go to the clips-slot->slot-des% function, , @t{clips-slot->slot-des%}} (function)
@item
@ref{go to the clips-slot-spec-p function, , @t{clips-slot-spec-p}} (function)
@item
@ref{go to the extract-conditions% function, , @t{extract-conditions%}} (function)
@item
@ref{go to the modify% integer t method, , @t{modify%}} (method)
@item
@ref{go to the modify% list t method, , @t{modify%}} (method)
@item
@ref{go to the my-position function, , @t{my-position}} (function)
@item
@ref{go to the nonclips-mod-list-p function, , @t{nonclips-mod-list-p}} (function)
@item
@ref{go to the nonclips-slot->slot-des% function, , @t{nonclips-slot->slot-des%}} (function)
@item
@ref{go to the nonclips-slot-spec-p function, , @t{nonclips-slot-spec-p}} (function)
@item
@ref{go to the ppdefrule% function, , @t{ppdefrule%}} (function)
@item
@ref{go to the retract% function, , @t{retract%}} (function)
@item
@ref{go to the set-clips-mode function, , @t{set-clips-mode}} (function)
@item
@ref{go to the slot->slot-designator% function, , @t{slot->slot-designator%}} (function)
@item
@ref{go to the slot-spec-p function, , @t{slot-spec-p}} (function)
@item
@ref{go to the slots->slot-designators% function, , @t{slots->slot-designators%}} (function)
@item
@ref{go to the to-mod-spec-list function, , @t{to-mod-spec-list}} (function)
@end itemize
@end table



@c ====================================================================
@c Packages
@c ====================================================================
@node Packages, Definitions, Files, Top
@chapter Packages

Packages are listed by definition order.

@menu
* The exil-system package::
* The exil-utils package::
* The exil-core package::
* The exil-rete package::
* The exil-env package::
* The exil package::
* The exil-user package::
@end menu


@c -----------------------
@c The exil-system package
@c -----------------------
@node The exil-system package, The exil-utils package, Packages, Packages
@section @t{exil-system}

@anchor{go to the exil-system package}@c
@packageindex{exil-system}@c
contains the ExiL ASDF system@table @strong
@item Source
@ref{go to the exil.asd file, , @t{exil.asd}} (Lisp file)
@item Use List
@itemize @bullet
@item
@t{asdf}
@item
@t{common-lisp}
@end itemize
@end table


@c ----------------------
@c The exil-utils package
@c ----------------------
@node The exil-utils package, The exil-core package, The exil-system package, Packages
@section @t{exil-utils}

@anchor{go to the exil-utils package}@c
@packageindex{exil-utils}@c
general purpose utilities used in the rest of the code@table @strong
@item Source
@ref{go to the packages.lisp file, , @t{packages}} (Lisp file)
@item Use List
@t{common-lisp}
@item Used By List
@itemize @bullet
@item
@ref{go to the exil package, , @t{exil}}
@item
@ref{go to the exil-env package, , @t{exil-env}}
@item
@ref{go to the exil-rete package, , @t{exil-rete}}
@item
@ref{go to the exil-core package, , @t{exil-core}}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the alistp function, , @t{alistp}} (function)
@item
@ref{go to the assoc-key function, , @t{assoc-key}} (function)
@item
@ref{go to the assoc-value function, , @t{assoc-value}} (function)
@item
@ref{go to the (setf assoc-value) function, , @t{(setf assoc-value)}} (function)
@item
@ref{go to the class-slot-value function, , @t{class-slot-value}} (function)
@item
@ref{go to the cpl-assoc-val function, , @t{cpl-assoc-val}} (function)
@item
@ref{go to the (setf cpl-assoc-val) function, , @t{(setf cpl-assoc-val)}} (function)
@item
@ref{go to the diff-delete macro, , @t{diff-delete}} (macro)
@item
@ref{go to the doplist macro, , @t{doplist}} (macro)
@item
@ref{go to the every-couple function, , @t{every-couple}} (function)
@item
@ref{go to the exil-equal-p generic function, , @t{exil-equal-p}} (generic function)
@item
@ref{go to the exil-equal-p cons cons method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p number number method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p symbol symbol method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p string string method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p t t method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-equal-p null null method, , @t{exil-equal-p}} (method)
@item
@ref{go to the exil-weak-equal-p generic function, , @t{exil-weak-equal-p}} (generic function)
@item
@ref{go to the exil-weak-equal-p cons cons method, , @t{exil-weak-equal-p}} (method)
@item
@ref{go to the exil-weak-equal-p symbol symbol method, , @t{exil-weak-equal-p}} (method)
@item
@ref{go to the exil-weak-equal-p t t method, , @t{exil-weak-equal-p}} (method)
@item
@ref{go to the ext-delete macro, , @t{ext-delete}} (macro)
@item
@ref{go to the ext-pushnew macro, , @t{ext-pushnew}} (macro)
@item
@ref{go to the from-keyword function, , @t{from-keyword}} (function)
@item
@ref{go to the hash->list generic function, , @t{hash->list}} (generic function)
@item
@ref{go to the hash->list hash-table method, , @t{hash->list}} (method)
@item
@ref{go to the intern function, , @t{intern}} (function)
@item
@ref{go to the mac-exp macro, , @t{mac-exp}} (macro)
@item
@ref{go to the plistp function, , @t{plistp}} (function)
@item
@ref{go to the push-end macro, , @t{push-end}} (macro)
@item
@ref{go to the push-update macro, , @t{push-update}} (macro)
@item
@ref{go to the pushnew-end macro, , @t{pushnew-end}} (macro)
@item
@ref{go to the select function, , @t{select}} (function)
@item
@ref{go to the string-append function, , @t{string-append}} (function)
@item
@ref{go to the subsets function, , @t{subsets}} (function)
@item
@ref{go to the symbol-append function, , @t{symbol-append}} (function)
@item
@ref{go to the symbol-name generic function, , @t{symbol-name}} (generic function)
@item
@ref{go to the symbol-name symbol method, , @t{symbol-name}} (method)
@item
@ref{go to the symbol-name string method, , @t{symbol-name}} (method)
@item
@ref{go to the to-keyword function, , @t{to-keyword}} (function)
@item
@ref{go to the to-list function, , @t{to-list}} (function)
@item
@ref{go to the to-list-of-lists function, , @t{to-list-of-lists}} (function)
@item
@ref{go to the weak-symbol-equal-p generic function, , @t{weak-symbol-equal-p}} (generic function)
@item
@ref{go to the weak-symbol-equal-p symbol symbol method, , @t{weak-symbol-equal-p}} (method)
@item
@ref{go to the weak-symbol-equal-p t t method, , @t{weak-symbol-equal-p}} (method)
@end itemize
@end table


@c ---------------------
@c The exil-core package
@c ---------------------
@node The exil-core package, The exil-rete package, The exil-utils package, Packages
@section @t{exil-core}

@anchor{go to the exil-core package}@c
@packageindex{exil-core}@c
core functionality of the expert system library - facts, templates, patterns and rules@table @strong
@item Source
@ref{go to the packages.lisp file, , @t{packages}} (Lisp file)
@item Use List
@itemize @bullet
@item
@t{common-lisp}
@item
@ref{go to the exil-utils package, , @t{exil-utils}}
@end itemize
@item Used By List
@itemize @bullet
@item
@ref{go to the exil package, , @t{exil}}
@item
@ref{go to the exil-env package, , @t{exil-env}}
@item
@ref{go to the exil-rete package, , @t{exil-rete}}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the activations generic function, , @t{activations}} (generic function)
@item
@ref{go to the activations rule method, , @t{activations}} (method)
@item
@ref{go to the atom-equal-p generic function, , @t{atom-equal-p}} (generic function)
@item
@ref{go to the atom-equal-p t t method, , @t{atom-equal-p}} (method)
@item
@ref{go to the atom-position generic function, , @t{atom-position}} (generic function)
@item
@ref{go to the atom-position simple-pattern t method, , @t{atom-position}} (method)
@item
@ref{go to the atom-position simple-fact t method, , @t{atom-position}} (method)
@item
@ref{go to the atom-position template-object t method, , @t{atom-position}} (method)
@item
@ref{go to the conditions generic function, , @t{conditions}} (generic function)
@item
@ref{go to the conditions rule method, , @t{conditions}} (method)
@item
@ref{go to the constant-test function, , @t{constant-test}} (function)
@item
@ref{go to the copy-fact generic function, , @t{copy-fact}} (generic function)
@item
@ref{go to the copy-fact fact method, , @t{copy-fact}} (method)
@item
@ref{go to the fact generic function, , @t{fact}} (generic function)
@item
@ref{go to the fact simple-fact method, , @t{fact}} (method)
@item
@ref{go to the fact class, , @t{fact}} (class)
@item
@ref{go to the fact-description generic function, , @t{fact-description}} (generic function)
@item
@ref{go to the fact-description template-fact method, , @t{fact-description}} (method)
@item
@ref{go to the fact-description simple-fact method, , @t{fact-description}} (method)
@item
@ref{go to the fact-equal-p generic function, , @t{fact-equal-p}} (generic function)
@item
@ref{go to the fact-equal-p template-fact template-fact method, , @t{fact-equal-p}} (method)
@item
@ref{go to the fact-equal-p simple-fact simple-fact method, , @t{fact-equal-p}} (method)
@item
@ref{go to the fact-equal-p t t method, , @t{fact-equal-p}} (method)
@item
@ref{go to the fact-slot generic function, , @t{fact-slot}} (generic function)
@item
@ref{go to the fact-slot simple-fact integer method, , @t{fact-slot}} (method)
@item
@ref{go to the fact-slot template-fact symbol method, , @t{fact-slot}} (method)
@item
@ref{go to the find-atom generic function, , @t{find-atom}} (generic function)
@item
@ref{go to the find-atom simple-pattern t method, , @t{find-atom}} (method)
@item
@ref{go to the find-atom simple-fact t method, , @t{find-atom}} (method)
@item
@ref{go to the find-atom template-object t method, , @t{find-atom}} (method)
@item
@ref{go to the has-slot-p generic function, , @t{has-slot-p}} (generic function)
@item
@ref{go to the has-slot-p template-object t method, , @t{has-slot-p}} (method)
@item
@ref{go to the make-fact function, , @t{make-fact}} (function)
@item
@ref{go to the make-pattern function, , @t{make-pattern}} (function)
@item
@ref{go to the make-rule generic function, , @t{make-rule}} (generic function)
@item
@ref{go to the make-rule t t t method, , @t{make-rule}} (method)
@item
@ref{go to the make-template function, , @t{make-template}} (function)
@item
@ref{go to the match-var generic function, , @t{match-var}} (generic function)
@item
@ref{go to the match-var pattern method, , @t{match-var}} (method)
@item
@ref{go to the (setf match-var) t pattern method, , @t{(setf match-var)}} (method)
@item
@ref{go to the (setf match-var) generic function, , @t{(setf match-var)}} (generic function)
@item
@ref{go to the name generic function, , @t{name}} (generic function)
@item
@ref{go to the name rule method, , @t{name}} (method)
@item
@ref{go to the name template method, , @t{name}} (method)
@item
@ref{go to the negated-p generic function, , @t{negated-p}} (generic function)
@item
@ref{go to the negated-p pattern method, , @t{negated-p}} (method)
@item
@ref{go to the (setf negated-p) t pattern method, , @t{(setf negated-p)}} (method)
@item
@ref{go to the (setf negated-p) generic function, , @t{(setf negated-p)}} (generic function)
@item
@ref{go to the pattern generic function, , @t{pattern}} (generic function)
@item
@ref{go to the pattern simple-pattern method, , @t{pattern}} (method)
@item
@ref{go to the pattern class, , @t{pattern}} (class)
@item
@ref{go to the pattern-equal-p generic function, , @t{pattern-equal-p}} (generic function)
@item
@ref{go to the pattern-equal-p template-pattern template-pattern method, , @t{pattern-equal-p}} (method)
@item
@ref{go to the pattern-equal-p simple-pattern simple-pattern method, , @t{pattern-equal-p}} (method)
@item
@ref{go to the pattern-equal-p pattern pattern method, , @t{pattern-equal-p}} (method)
@item
@ref{go to the rule class, , @t{rule}} (class)
@item
@ref{go to the rule-equal-p generic function, , @t{rule-equal-p}} (generic function)
@item
@ref{go to the rule-equal-p rule rule method, , @t{rule-equal-p}} (method)
@item
@ref{go to the simple-fact class, , @t{simple-fact}} (class)
@item
@ref{go to the simple-pattern class, , @t{simple-pattern}} (class)
@item
@ref{go to the slots generic function, , @t{slots}} (generic function)
@item
@ref{go to the slots template-object method, , @t{slots}} (method)
@item
@ref{go to the slots template method, , @t{slots}} (method)
@item
@ref{go to the template class, , @t{template}} (class)
@item
@ref{go to the template-fact class, , @t{template-fact}} (class)
@item
@ref{go to the template-pattern class, , @t{template-pattern}} (class)
@item
@ref{go to the tmpl-fact-slot-value generic function, , @t{tmpl-fact-slot-value}} (generic function)
@item
@ref{go to the tmpl-fact-slot-value template-fact t method, , @t{tmpl-fact-slot-value}} (method)
@item
@ref{go to the (setf tmpl-fact-slot-value) t template-fact t method, , @t{(setf tmpl-fact-slot-value)}} (method)
@item
@ref{go to the (setf tmpl-fact-slot-value) generic function, , @t{(setf tmpl-fact-slot-value)}} (generic function)
@item
@ref{go to the tmpl-name generic function, , @t{tmpl-name}} (generic function)
@item
@ref{go to the tmpl-name template-object method, , @t{tmpl-name}} (method)
@item
@ref{go to the var-or-equal-p function, , @t{var-or-equal-p}} (function)
@item
@ref{go to the variable-p function, , @t{variable-p}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the clips-tmpl-slot-spec-p function, , @t{clips-tmpl-slot-spec-p}} (function)
@item
@ref{go to the make-tmpl-fact function, , @t{make-tmpl-fact}} (function)
@item
@ref{go to the make-tmpl-obj-clips function, , @t{make-tmpl-obj-clips}} (function)
@item
@ref{go to the make-tmpl-obj-nonclips function, , @t{make-tmpl-obj-nonclips}} (function)
@item
@ref{go to the make-tmpl-object function, , @t{make-tmpl-object}} (function)
@item
@ref{go to the make-tmpl-pattern function, , @t{make-tmpl-pattern}} (function)
@item
@ref{go to the template-object class, , @t{template-object}} (class)
@item
@ref{go to the tmpl-fact-specification-p function, , @t{tmpl-fact-specification-p}} (function)
@item
@ref{go to the tmpl-object-equal-p generic function, , @t{tmpl-object-equal-p}} (generic function)
@item
@ref{go to the tmpl-object-equal-p template-object template-object method, , @t{tmpl-object-equal-p}} (method)
@item
@ref{go to the tmpl-object-slot-value generic function, , @t{tmpl-object-slot-value}} (generic function)
@item
@ref{go to the tmpl-object-slot-value template-object t method, , @t{tmpl-object-slot-value}} (method)
@item
@ref{go to the (setf tmpl-object-slot-value) t template-object t method, , @t{(setf tmpl-object-slot-value)}} (method)
@item
@ref{go to the (setf tmpl-object-slot-value) generic function, , @t{(setf tmpl-object-slot-value)}} (generic function)
@item
@ref{go to the tmpl-object-specification-p function, , @t{tmpl-object-specification-p}} (function)
@item
@ref{go to the tmpl-pattern-slot-value generic function, , @t{tmpl-pattern-slot-value}} (generic function)
@item
@ref{go to the tmpl-pattern-slot-value template-pattern t method, , @t{tmpl-pattern-slot-value}} (method)
@item
@ref{go to the tmpl-pattern-specification-p function, , @t{tmpl-pattern-specification-p}} (function)
@item
@ref{go to the tmpl-slot-spec-p function, , @t{tmpl-slot-spec-p}} (function)
@end itemize
@end table


@c ---------------------
@c The exil-rete package
@c ---------------------
@node The exil-rete package, The exil-env package, The exil-core package, Packages
@section @t{exil-rete}

@anchor{go to the exil-rete package}@c
@packageindex{exil-rete}@c
the rete algorithm for matching facts against rule conditions@table @strong
@item Source
@ref{go to the packages.lisp file, , @t{packages}} (Lisp file)
@item Use List
@itemize @bullet
@item
@t{common-lisp}
@item
@ref{go to the exil-utils package, , @t{exil-utils}}
@item
@ref{go to the exil-core package, , @t{exil-core}}
@end itemize
@item Used By List
@ref{go to the exil-env package, , @t{exil-env}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the add-wme generic function, , @t{add-wme}} (generic function)
@item
@ref{go to the add-wme fact method, , @t{add-wme}} (method)
@item
@ref{go to the make-rete function, , @t{make-rete}} (function)
@item
@ref{go to the new-production generic function, , @t{new-production}} (generic function)
@item
@ref{go to the new-production rule method, , @t{new-production}} (method)
@item
@ref{go to the rem-wme generic function, , @t{rem-wme}} (generic function)
@item
@ref{go to the rem-wme fact method, , @t{rem-wme}} (method)
@item
@ref{go to the remove-production generic function, , @t{remove-production}} (generic function)
@item
@ref{go to the remove-production rule method, , @t{remove-production}} (method)
@item
@ref{go to the token->list generic function, , @t{token->list}} (generic function)
@item
@ref{go to the token->list token method, , @t{token->list}} (method)
@item
@ref{go to the token-equal-p generic function, , @t{token-equal-p}} (generic function)
@item
@ref{go to the token-equal-p t t method, , @t{token-equal-p}} (method)
@item
@ref{go to the token-equal-p empty-token empty-token method, , @t{token-equal-p}} (method)
@item
@ref{go to the token-equal-p token token method, , @t{token-equal-p}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the activate generic function, , @t{activate}} (generic function)
@item
@ref{go to the activate beta-negative-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate beta-negative-node token method, , @t{activate}} (method)
@item
@ref{go to the activate beta-join-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate beta-join-node token method, , @t{activate}} (method)
@item
@ref{go to the activate beta-memory-node token method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-memory-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-top-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-subtop-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-test-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate-children generic function, , @t{activate-children}} (generic function)
@item
@ref{go to the activate-children alpha-test-node fact method, , @t{activate-children}} (method)
@item
@ref{go to the activate-children node t method, , @t{activate-children}} (method)
@item
@ref{go to the activate-memory generic function, , @t{activate-memory}} (generic function)
@item
@ref{go to the activate-memory alpha-test-node fact method, , @t{activate-memory}} (method)
@item
@ref{go to the add-child generic function, , @t{add-child}} (generic function)
@item
@ref{go to the add-child node node method, , @t{add-child}} (method)
@item
@ref{go to the add-children generic function, , @t{add-children}} (generic function)
@item
@ref{go to the add-children node list method, , @t{add-children}} (method)
@item
@ref{go to the add-item generic function, , @t{add-item}} (generic function)
@item
@ref{go to the add-item memory-node t method, , @t{add-item}} (method)
@item
@ref{go to the add-production generic function, , @t{add-production}} (generic function)
@item
@ref{go to the add-production beta-memory-node rule method, , @t{add-production}} (method)
@item
@ref{go to the alpha-memory generic function, , @t{alpha-memory}} (generic function)
@item
@ref{go to the alpha-memory beta-join-node method, , @t{alpha-memory}} (method)
@item
@ref{go to the alpha-memory-node class, , @t{alpha-memory-node}} (class)
@item
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item
@ref{go to the alpha-subtop-node class, , @t{alpha-subtop-node}} (class)
@item
@ref{go to the alpha-test-node class, , @t{alpha-test-node}} (class)
@item
@ref{go to the alpha-top-node generic function, , @t{alpha-top-node}} (generic function)
@item
@ref{go to the alpha-top-node rete method, , @t{alpha-top-node}} (method)
@item
@ref{go to the alpha-top-node class, , @t{alpha-top-node}} (class)
@item
@ref{go to the beta-join-node class, , @t{beta-join-node}} (class)
@item
@ref{go to the beta-memory generic function, , @t{beta-memory}} (generic function)
@item
@ref{go to the beta-memory beta-join-node method, , @t{beta-memory}} (method)
@item
@ref{go to the beta-memory-node class, , @t{beta-memory-node}} (class)
@item
@ref{go to the beta-negative-node class, , @t{beta-negative-node}} (class)
@item
@ref{go to the beta-node class, , @t{beta-node}} (class)
@item
@ref{go to the beta-top-node generic function, , @t{beta-top-node}} (generic function)
@item
@ref{go to the beta-top-node rete method, , @t{beta-top-node}} (method)
@item
@ref{go to the (setf beta-top-node) t rete method, , @t{(setf beta-top-node)}} (method)
@item
@ref{go to the (setf beta-top-node) generic function, , @t{(setf beta-top-node)}} (generic function)
@item
@ref{go to the beta-top-node class, , @t{beta-top-node}} (class)
@item
@ref{go to the broken-match generic function, , @t{broken-match}} (generic function)
@item
@ref{go to the broken-match beta-memory-node token method, , @t{broken-match}} (method)
@item
@ref{go to the children generic function, , @t{children}} (generic function)
@item
@ref{go to the children node method, , @t{children}} (method)
@item
@ref{go to the (setf children) t node method, , @t{(setf children)}} (method)
@item
@ref{go to the (setf children) generic function, , @t{(setf children)}} (generic function)
@item
@ref{go to the complete-match generic function, , @t{complete-match}} (generic function)
@item
@ref{go to the complete-match beta-memory-node token method, , @t{complete-match}} (method)
@item
@ref{go to the create-alpha-net generic function, , @t{create-alpha-net}} (generic function)
@item
@ref{go to the create-alpha-net template-pattern method, , @t{create-alpha-net}} (method)
@item
@ref{go to the create-alpha-net simple-pattern method, , @t{create-alpha-net}} (method)
@item
@ref{go to the create-alpha-net% generic function, , @t{create-alpha-net%}} (generic function)
@item
@ref{go to the create-alpha-net% template-pattern template-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@item
@ref{go to the create-alpha-net% simple-pattern simple-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@item
@ref{go to the current-field generic function, , @t{current-field}} (generic function)
@item
@ref{go to the current-field test method, , @t{current-field}} (method)
@item
@ref{go to the delete-production generic function, , @t{delete-production}} (generic function)
@item
@ref{go to the delete-production beta-memory-node rule method, , @t{delete-production}} (method)
@item
@ref{go to the described-object class, , @t{described-object}} (class)
@item
@ref{go to the description generic function, , @t{description}} (generic function)
@item
@ref{go to the description described-object method, , @t{description}} (method)
@item
@ref{go to the (setf description) t described-object method, , @t{(setf description)}} (method)
@item
@ref{go to the (setf description) generic function, , @t{(setf description)}} (generic function)
@item
@ref{go to the empty-token class, , @t{empty-token}} (class)
@item
@ref{go to the find-atom-in-cond-list% function, , @t{find-atom-in-cond-list%}} (function)
@item
@ref{go to the find-test-node generic function, , @t{find-test-node}} (generic function)
@item
@ref{go to the find-test-node alpha-node t t method, , @t{find-test-node}} (method)
@item
@ref{go to the find/create-join-node generic function, , @t{find/create-join-node}} (generic function)
@item
@ref{go to the find/create-join-node beta-memory-node list alpha-memory-node method, , @t{find/create-join-node}} (method)
@item
@ref{go to the find/create-neg-node generic function, , @t{find/create-neg-node}} (generic function)
@item
@ref{go to the find/create-neg-node beta-memory-node list alpha-memory-node method, , @t{find/create-neg-node}} (method)
@item
@ref{go to the find/create-test-node generic function, , @t{find/create-test-node}} (generic function)
@item
@ref{go to the find/create-test-node simple-fact-alpha-node t t method, , @t{find/create-test-node}} (method)
@item
@ref{go to the find/create-test-node template-fact-alpha-node t t method, , @t{find/create-test-node}} (method)
@item
@ref{go to the find/create-test-node% generic function, , @t{find/create-test-node%}} (generic function)
@item
@ref{go to the find/create-test-node% t t t t method, , @t{find/create-test-node%}} (method)
@item
@ref{go to the get-bad-wmes generic function, , @t{get-bad-wmes}} (generic function)
@item
@ref{go to the get-bad-wmes beta-negative-node token method, , @t{get-bad-wmes}} (method)
@item
@ref{go to the get-intercondition-tests% generic function, , @t{get-intercondition-tests%}} (generic function)
@item
@ref{go to the get-intercondition-tests% template-pattern list method, , @t{get-intercondition-tests%}} (method)
@item
@ref{go to the get-intercondition-tests% simple-pattern list method, , @t{get-intercondition-tests%}} (method)
@item
@ref{go to the get-intracondition-tests% generic function, , @t{get-intracondition-tests%}} (generic function)
@item
@ref{go to the get-intracondition-tests% template-pattern method, , @t{get-intracondition-tests%}} (method)
@item
@ref{go to the get-intracondition-tests% simple-pattern method, , @t{get-intracondition-tests%}} (method)
@item
@ref{go to the get-join-tests-from-condition generic function, , @t{get-join-tests-from-condition}} (generic function)
@item
@ref{go to the get-join-tests-from-condition pattern list method, , @t{get-join-tests-from-condition}} (method)
@item
@ref{go to the get-network generic function, , @t{get-network}} (generic function)
@item
@ref{go to the get-network alpha-top-node method, , @t{get-network}} (method)
@item
@ref{go to the (setf get-network) t alpha-top-node method, , @t{(setf get-network)}} (method)
@item
@ref{go to the (setf get-network) generic function, , @t{(setf get-network)}} (generic function)
@item
@ref{go to the get/initialize-network generic function, , @t{get/initialize-network}} (generic function)
@item
@ref{go to the get/initialize-network alpha-top-node method, , @t{get/initialize-network}} (method)
@item
@ref{go to the inactivate generic function, , @t{inactivate}} (generic function)
@item
@ref{go to the inactivate beta-negative-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate beta-memory-node token before method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate beta-memory-node fact before method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate alpha-memory-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate alpha-top-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate alpha-test-node fact after method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate node t method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate-children generic function, , @t{inactivate-children}} (generic function)
@item
@ref{go to the inactivate-children node t method, , @t{inactivate-children}} (method)
@item
@ref{go to the includes-p generic function, , @t{includes-p}} (generic function)
@item
@ref{go to the includes-p token token method, , @t{includes-p}} (method)
@item
@ref{go to the includes-p fact token method, , @t{includes-p}} (method)
@item
@ref{go to the initialize-network generic function, , @t{initialize-network}} (generic function)
@item
@ref{go to the initialize-network alpha-top-node method, , @t{initialize-network}} (method)
@item
@ref{go to the items generic function, , @t{items}} (generic function)
@item
@ref{go to the items memory-node method, , @t{items}} (method)
@item
@ref{go to the (setf items) t memory-node method, , @t{(setf items)}} (method)
@item
@ref{go to the (setf items) generic function, , @t{(setf items)}} (generic function)
@item
@ref{go to the make-test function, , @t{make-test}} (function)
@item
@ref{go to the memory generic function, , @t{memory}} (generic function)
@item
@ref{go to the memory alpha-test-node method, , @t{memory}} (method)
@item
@ref{go to the (setf memory) t alpha-test-node method, , @t{(setf memory)}} (method)
@item
@ref{go to the (setf memory) generic function, , @t{(setf memory)}} (generic function)
@item
@ref{go to the memory-node class, , @t{memory-node}} (class)
@item
@ref{go to the negative-wmes generic function, , @t{negative-wmes}} (generic function)
@item
@ref{go to the negative-wmes token method, , @t{negative-wmes}} (method)
@item
@ref{go to the (setf negative-wmes) t token method, , @t{(setf negative-wmes)}} (method)
@item
@ref{go to the (setf negative-wmes) generic function, , @t{(setf negative-wmes)}} (generic function)
@item
@ref{go to the networks generic function, , @t{networks}} (generic function)
@item
@ref{go to the networks alpha-top-node method, , @t{networks}} (method)
@item
@ref{go to the (setf networks) t alpha-top-node method, , @t{(setf networks)}} (method)
@item
@ref{go to the (setf networks) generic function, , @t{(setf networks)}} (generic function)
@item
@ref{go to the node class, , @t{node}} (class)
@item
@ref{go to the node-equal-p generic function, , @t{node-equal-p}} (generic function)
@item
@ref{go to the node-equal-p beta-join-node beta-join-node method, , @t{node-equal-p}} (method)
@item
@ref{go to the node-equal-p alpha-test-node alpha-test-node method, , @t{node-equal-p}} (method)
@item
@ref{go to the node-equal-p (eql nil) (eql nil) method, , @t{node-equal-p}} (method)
@item
@ref{go to the node-equal-p node node method, , @t{node-equal-p}} (method)
@item
@ref{go to the parent generic function, , @t{parent}} (generic function)
@item
@ref{go to the parent beta-node method, , @t{parent}} (method)
@item
@ref{go to the (setf parent) t beta-node method, , @t{(setf parent)}} (method)
@item
@ref{go to the parent token method, , @t{parent}} (method)
@item
@ref{go to the (setf parent) generic function, , @t{(setf parent)}} (generic function)
@item
@ref{go to the perform-join-test generic function, , @t{perform-join-test}} (generic function)
@item
@ref{go to the perform-join-test test token fact method, , @t{perform-join-test}} (method)
@item
@ref{go to the perform-join-tests generic function, , @t{perform-join-tests}} (generic function)
@item
@ref{go to the perform-join-tests list token fact method, , @t{perform-join-tests}} (method)
@item
@ref{go to the previous-condition generic function, , @t{previous-condition}} (generic function)
@item
@ref{go to the previous-condition test method, , @t{previous-condition}} (method)
@item
@ref{go to the previous-field generic function, , @t{previous-field}} (generic function)
@item
@ref{go to the previous-field test method, , @t{previous-field}} (method)
@item
@ref{go to the previous-wme generic function, , @t{previous-wme}} (generic function)
@item
@ref{go to the previous-wme token method, , @t{previous-wme}} (method)
@item
@ref{go to the productions generic function, , @t{productions}} (generic function)
@item
@ref{go to the productions beta-memory-node method, , @t{productions}} (method)
@item
@ref{go to the (setf productions) t beta-memory-node method, , @t{(setf productions)}} (method)
@item
@ref{go to the (setf productions) generic function, , @t{(setf productions)}} (generic function)
@item
@ref{go to the rete class, , @t{rete}} (class)
@item
@ref{go to the simple-fact-alpha-node class, , @t{simple-fact-alpha-node}} (class)
@item
@ref{go to the simple-fact-key-name generic function, , @t{simple-fact-key-name}} (generic function)
@item
@ref{go to the simple-fact-key-name alpha-top-node method, , @t{simple-fact-key-name}} (method)
@item
@ref{go to the simple-fact-subtop-node class, , @t{simple-fact-subtop-node}} (class)
@item
@ref{go to the simple-fact-test-node class, , @t{simple-fact-test-node}} (class)
@item
@ref{go to the template-fact-alpha-node class, , @t{template-fact-alpha-node}} (class)
@item
@ref{go to the template-fact-subtop-node class, , @t{template-fact-subtop-node}} (class)
@item
@ref{go to the template-fact-test-node class, , @t{template-fact-test-node}} (class)
@item
@ref{go to the test generic function, , @t{test}} (generic function)
@item
@ref{go to the test template-fact-test-node template-fact method, , @t{test}} (method)
@item
@ref{go to the test simple-fact-test-node simple-fact method, , @t{test}} (method)
@item
@ref{go to the test alpha-test-node fact method, , @t{test}} (method)
@item
@ref{go to the test class, , @t{test}} (class)
@item
@ref{go to the test-equal-p generic function, , @t{test-equal-p}} (generic function)
@item
@ref{go to the test-equal-p test test method, , @t{test-equal-p}} (method)
@item
@ref{go to the tested-field generic function, , @t{tested-field}} (generic function)
@item
@ref{go to the tested-field alpha-test-node method, , @t{tested-field}} (method)
@item
@ref{go to the tests generic function, , @t{tests}} (generic function)
@item
@ref{go to the tests beta-join-node method, , @t{tests}} (method)
@item
@ref{go to the (setf tests) t beta-join-node method, , @t{(setf tests)}} (method)
@item
@ref{go to the (setf tests) generic function, , @t{(setf tests)}} (generic function)
@item
@ref{go to the tests-equal-p generic function, , @t{tests-equal-p}} (generic function)
@item
@ref{go to the tests-equal-p list list method, , @t{tests-equal-p}} (method)
@item
@ref{go to the token generic function, , @t{token}} (generic function)
@item
@ref{go to the token t method, , @t{token}} (method)
@item
@ref{go to the token class, , @t{token}} (class)
@item
@ref{go to the value generic function, , @t{value}} (generic function)
@item
@ref{go to the value alpha-test-node method, , @t{value}} (method)
@item
@ref{go to the wme generic function, , @t{wme}} (generic function)
@item
@ref{go to the wme token method, , @t{wme}} (method)
@end itemize
@end table


@c --------------------
@c The exil-env package
@c --------------------
@node The exil-env package, The exil package, The exil-rete package, Packages
@section @t{exil-env}

@anchor{go to the exil-env package}@c
@packageindex{exil-env}@c
the exil environment, keeps track of the defined templates and rules and stores the asserted facts@table @strong
@item Source
@ref{go to the packages.lisp file, , @t{packages}} (Lisp file)
@item Use List
@itemize @bullet
@item
@t{common-lisp}
@item
@ref{go to the exil-utils package, , @t{exil-utils}}
@item
@ref{go to the exil-core package, , @t{exil-core}}
@item
@ref{go to the exil-rete package, , @t{exil-rete}}
@end itemize
@item Used By List
@ref{go to the exil package, , @t{exil}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the activate-rule generic function, , @t{activate-rule}} (generic function)
@item
@ref{go to the activate-rule match method, , @t{activate-rule}} (method)
@item
@ref{go to the add-fact function, , @t{add-fact}} (function)
@item
@ref{go to the add-fact-group function, , @t{add-fact-group}} (function)
@item
@ref{go to the add-match generic function, , @t{add-match}} (generic function)
@item
@ref{go to the add-match t t method, , @t{add-match}} (method)
@item
@ref{go to the add-rule function, , @t{add-rule}} (function)
@item
@ref{go to the add-strategy generic function, , @t{add-strategy}} (generic function)
@item
@ref{go to the add-strategy t t method, , @t{add-strategy}} (method)
@item
@ref{go to the add-template function, , @t{add-template}} (function)
@item
@ref{go to the agenda generic function, , @t{agenda}} (generic function)
@item
@ref{go to the agenda method, , @t{agenda}} (method)
@item
@ref{go to the fact-groups generic function, , @t{fact-groups}} (generic function)
@item
@ref{go to the fact-groups method, , @t{fact-groups}} (method)
@item
@ref{go to the facts generic function, , @t{facts}} (generic function)
@item
@ref{go to the facts method, , @t{facts}} (method)
@item
@ref{go to the find-fact function, , @t{find-fact}} (function)
@item
@ref{go to the find-rule function, , @t{find-rule}} (function)
@item
@ref{go to the find-template generic function, , @t{find-template}} (generic function)
@item
@ref{go to the find-template t method, , @t{find-template}} (method)
@item
@ref{go to the modify-fact function, , @t{modify-fact}} (function)
@item
@ref{go to the rem-fact function, , @t{rem-fact}} (function)
@item
@ref{go to the rem-fact-group function, , @t{rem-fact-group}} (function)
@item
@ref{go to the rem-rule function, , @t{rem-rule}} (function)
@item
@ref{go to the remove-match generic function, , @t{remove-match}} (generic function)
@item
@ref{go to the remove-match t t method, , @t{remove-match}} (method)
@item
@ref{go to the reset-environment function, , @t{reset-environment}} (function)
@item
@ref{go to the reset-facts function, , @t{reset-facts}} (function)
@item
@ref{go to the rete generic function, , @t{rete}} (generic function)
@item
@ref{go to the rete method, , @t{rete}} (method)
@item
@ref{go to the rules generic function, , @t{rules}} (generic function)
@item
@ref{go to the rules method, , @t{rules}} (method)
@item
@ref{go to the select-activation generic function, , @t{select-activation}} (generic function)
@item
@ref{go to the select-activation method, , @t{select-activation}} (method)
@item
@ref{go to the set-strategy generic function, , @t{set-strategy}} (generic function)
@item
@ref{go to the set-strategy method, , @t{set-strategy}} (method)
@item
@ref{go to the set-watcher generic function, , @t{set-watcher}} (generic function)
@item
@ref{go to the set-watcher t method, , @t{set-watcher}} (method)
@item
@ref{go to the templates generic function, , @t{templates}} (generic function)
@item
@ref{go to the templates method, , @t{templates}} (method)
@item
@ref{go to the unset-watcher generic function, , @t{unset-watcher}} (generic function)
@item
@ref{go to the unset-watcher t method, , @t{unset-watcher}} (method)
@item
@ref{go to the unwatch-all generic function, , @t{unwatch-all}} (generic function)
@item
@ref{go to the unwatch-all method, , @t{unwatch-all}} (method)
@item
@ref{go to the watch-all generic function, , @t{watch-all}} (generic function)
@item
@ref{go to the watch-all method, , @t{watch-all}} (method)
@item
@ref{go to the watched-p generic function, , @t{watched-p}} (generic function)
@item
@ref{go to the watched-p t method, , @t{watched-p}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the *current-environment* special variable, , @t{*current-environment*}} (special variable)
@item
@ref{go to the *environments* special variable, , @t{*environments*}} (special variable)
@item
@ref{go to the breadth-strategy function, , @t{breadth-strategy}} (function)
@item
@ref{go to the completely-reset-environment function, , @t{completely-reset-environment}} (function)
@item
@ref{go to the complexity-strategy function, , @t{complexity-strategy}} (function)
@item
@ref{go to the current-strategy generic function, , @t{current-strategy}} (generic function)
@item
@ref{go to the current-strategy method, , @t{current-strategy}} (method)
@item
@ref{go to the current-strategy-name generic function, , @t{current-strategy-name}} (generic function)
@item
@ref{go to the current-strategy-name method, , @t{current-strategy-name}} (method)
@item
@ref{go to the defenv macro, , @t{defenv}} (macro)
@item
@ref{go to the depth-strategy function, , @t{depth-strategy}} (function)
@item
@ref{go to the exil-env-accessor macro, , @t{exil-env-accessor}} (macro)
@item
@ref{go to the exil-env-accessors macro, , @t{exil-env-accessors}} (macro)
@item
@ref{go to the exil-env-reader macro, , @t{exil-env-reader}} (macro)
@item
@ref{go to the exil-env-writer macro, , @t{exil-env-writer}} (macro)
@item
@ref{go to the exil-environment class, , @t{exil-environment}} (class)
@item
@ref{go to the get-variable-bindings function, , @t{get-variable-bindings}} (function)
@item
@ref{go to the is-watcher generic function, , @t{is-watcher}} (generic function)
@item
@ref{go to the is-watcher symbol method, , @t{is-watcher}} (method)
@item
@ref{go to the make-match function, , @t{make-match}} (function)
@item
@ref{go to the match class, , @t{match}} (class)
@item
@ref{go to the match-equal-p generic function, , @t{match-equal-p}} (generic function)
@item
@ref{go to the match-equal-p match match method, , @t{match-equal-p}} (method)
@item
@ref{go to the match-rule generic function, , @t{match-rule}} (generic function)
@item
@ref{go to the match-rule match method, , @t{match-rule}} (method)
@item
@ref{go to the match-token generic function, , @t{match-token}} (generic function)
@item
@ref{go to the match-token match method, , @t{match-token}} (method)
@item
@ref{go to the newer-than generic function, , @t{newer-than}} (generic function)
@item
@ref{go to the newer-than match match method, , @t{newer-than}} (method)
@item
@ref{go to the remove-matches generic function, , @t{remove-matches}} (generic function)
@item
@ref{go to the remove-matches t method, , @t{remove-matches}} (method)
@item
@ref{go to the setenv macro, , @t{setenv}} (macro)
@item
@ref{go to the simpler-than generic function, , @t{simpler-than}} (generic function)
@item
@ref{go to the simpler-than match match method, , @t{simpler-than}} (method)
@item
@ref{go to the simpler-than rule rule method, , @t{simpler-than}} (method)
@item
@ref{go to the simplicity-strategy function, , @t{simplicity-strategy}} (function)
@item
@ref{go to the strategies generic function, , @t{strategies}} (generic function)
@item
@ref{go to the strategies method, , @t{strategies}} (method)
@item
@ref{go to the substitute-variables function, , @t{substitute-variables}} (function)
@item
@ref{go to the timestamp generic function, , @t{timestamp}} (generic function)
@item
@ref{go to the timestamp match method, , @t{timestamp}} (method)
@item
@ref{go to the variable-bindings generic function, , @t{variable-bindings}} (generic function)
@item
@ref{go to the variable-bindings template-pattern template-fact method, , @t{variable-bindings}} (method)
@item
@ref{go to the variable-bindings simple-pattern simple-fact method, , @t{variable-bindings}} (method)
@item
@ref{go to the watchers generic function, , @t{watchers}} (generic function)
@item
@ref{go to the watchers method, , @t{watchers}} (method)
@end itemize
@end table


@c ----------------
@c The exil package
@c ----------------
@node The exil package, The exil-user package, The exil-env package, Packages
@section @t{exil}

@anchor{go to the exil package}@c
@packageindex{exil}@c
the main package, used by exil-user@table @strong
@item Source
@ref{go to the packages.lisp file, , @t{packages}} (Lisp file)
@item Use List
@itemize @bullet
@item
@t{common-lisp}
@item
@ref{go to the exil-utils package, , @t{exil-utils}}
@item
@ref{go to the exil-core package, , @t{exil-core}}
@item
@ref{go to the exil-env package, , @t{exil-env}}
@end itemize
@item Used By List
@ref{go to the exil-user package, , @t{exil-user}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the assert macro, , @t{assert}} (macro)
@item
@ref{go to the clear function, , @t{clear}} (function)
@item
@ref{go to the deffacts macro, , @t{deffacts}} (macro)
@item
@ref{go to the defrule macro, , @t{defrule}} (macro)
@item
@ref{go to the defstrategy macro, , @t{defstrategy}} (macro)
@item
@ref{go to the deftemplate macro, , @t{deftemplate}} (macro)
@item
@ref{go to the facts function, , @t{facts}} (function)
@item
@ref{go to the halt function, , @t{halt}} (function)
@item
@ref{go to the modify macro, , @t{modify}} (macro)
@item
@ref{go to the ppdefrule macro, , @t{ppdefrule}} (macro)
@item
@ref{go to the reset function, , @t{reset}} (function)
@item
@ref{go to the retract macro, , @t{retract}} (macro)
@item
@ref{go to the retract-all function, , @t{retract-all}} (function)
@item
@ref{go to the run function, , @t{run}} (function)
@item
@ref{go to the setstrategy macro, , @t{setstrategy}} (macro)
@item
@ref{go to the step function, , @t{step}} (function)
@item
@ref{go to the undeffacts macro, , @t{undeffacts}} (macro)
@item
@ref{go to the undefrule macro, , @t{undefrule}} (macro)
@item
@ref{go to the unwatch macro, , @t{unwatch}} (macro)
@item
@ref{go to the watch macro, , @t{watch}} (macro)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the *clips-mode* special variable, , @t{*clips-mode*}} (special variable)
@item
@ref{go to the *exil-running* special variable, , @t{*exil-running*}} (special variable)
@item
@ref{go to the assert% function, , @t{assert%}} (function)
@item
@ref{go to the assert-group% function, , @t{assert-group%}} (function)
@item
@ref{go to the clips->nonclips-mod-list function, , @t{clips->nonclips-mod-list}} (function)
@item
@ref{go to the clips-mod-list-p function, , @t{clips-mod-list-p}} (function)
@item
@ref{go to the clips-slot->slot-des% function, , @t{clips-slot->slot-des%}} (function)
@item
@ref{go to the clips-slot-spec-p function, , @t{clips-slot-spec-p}} (function)
@item
@ref{go to the extract-conditions% function, , @t{extract-conditions%}} (function)
@item
@ref{go to the modify% generic function, , @t{modify%}} (generic function)
@item
@ref{go to the modify% integer t method, , @t{modify%}} (method)
@item
@ref{go to the modify% list t method, , @t{modify%}} (method)
@item
@ref{go to the my-position function, , @t{my-position}} (function)
@item
@ref{go to the nonclips-mod-list-p function, , @t{nonclips-mod-list-p}} (function)
@item
@ref{go to the nonclips-slot->slot-des% function, , @t{nonclips-slot->slot-des%}} (function)
@item
@ref{go to the nonclips-slot-spec-p function, , @t{nonclips-slot-spec-p}} (function)
@item
@ref{go to the ppdefrule% function, , @t{ppdefrule%}} (function)
@item
@ref{go to the retract% function, , @t{retract%}} (function)
@item
@ref{go to the set-clips-mode function, , @t{set-clips-mode}} (function)
@item
@ref{go to the slot->slot-designator% function, , @t{slot->slot-designator%}} (function)
@item
@ref{go to the slot-spec-p function, , @t{slot-spec-p}} (function)
@item
@ref{go to the slots->slot-designators% function, , @t{slots->slot-designators%}} (function)
@item
@ref{go to the to-mod-spec-list function, , @t{to-mod-spec-list}} (function)
@end itemize
@end table


@c ---------------------
@c The exil-user package
@c ---------------------
@node The exil-user package, , The exil package, Packages
@section @t{exil-user}

@anchor{go to the exil-user package}@c
@packageindex{exil-user}@c
the user program is defined in this package@table @strong
@item Source
@ref{go to the packages.lisp file, , @t{packages}} (Lisp file)
@item Use List
@itemize @bullet
@item
@t{common-lisp}
@item
@ref{go to the exil package, , @t{exil}}
@end itemize
@end table



@c ====================================================================
@c Definitions
@c ====================================================================
@node Definitions, Indexes, Packages, Top
@chapter Definitions

Definitions are sorted by export status, category, package, and then by
lexicographic order.

@menu
* Exported definitions::
* Internal definitions::
@end menu


@c --------------------
@c Exported definitions
@c --------------------
@node Exported definitions, Internal definitions, Definitions, Definitions
@section Exported definitions

@menu
* Exported macros::
* Exported functions::
* Exported generic functions::
* Exported classes::
@end menu

@node Exported macros, Exported functions, Exported definitions, Exported definitions
@subsection Macros

@defmac assert &rest FACT-SPECS
@anchor{go to the assert macro}@c
@macrosubindex{assert}@c
Add fact into working memory@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac deffacts NAME &body FACT-DESCRIPTIONS
@anchor{go to the deffacts macro}@c
@macrosubindex{deffacts}@c
Create group of facts to be asserted after (reset)@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac defrule NAME &body RULE
@anchor{go to the defrule macro}@c
@macrosubindex{defrule}@c
Define rule@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac defstrategy NAME FUNCTION
@anchor{go to the defstrategy macro}@c
@macrosubindex{defstrategy}@c
Define strategy@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac deftemplate NAME &body SLOTS
@anchor{go to the deftemplate macro}@c
@macrosubindex{deftemplate}@c
define a fact template@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac diff-delete ITEM SEQUENCE &key TEST KEY
@anchor{go to the diff-delete macro}@c
@macrosubindex{diff-delete}@c
like delete, but as a second value returns list of deleted items@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac doplist (KEY VAL PLIST &optional RETVAL) &body BODY
@anchor{go to the doplist macro}@c
@macrosubindex{doplist}@c
iterates over plist setting key and val variables for each iteration@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac ext-delete ITEM PLACE &key TEST KEY
@anchor{go to the ext-delete macro}@c
@macrosubindex{ext-delete}@c
like delete, but as a second value returns, whether the list was actualy altered@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac ext-pushnew ITEM PLACE &key TEST KEY
@anchor{go to the ext-pushnew macro}@c
@macrosubindex{ext-pushnew}@c
like pushnew, but as a second value returns, whether the list was actualy altered@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac mac-exp &body BODY
@anchor{go to the mac-exp macro}@c
@macrosubindex{mac-exp}@c
shortcut for calling macroexpand-1@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac modify FACT-SPEC &rest MOD-LIST
@anchor{go to the modify macro}@c
@macrosubindex{modify}@c
Replace old-fact by new-fact@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac ppdefrule NAME
@anchor{go to the ppdefrule macro}@c
@macrosubindex{ppdefrule}@c
pretty prints rule definition@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac push-end ITEM LIST
@anchor{go to the push-end macro}@c
@macrosubindex{push-end}@c
pushes item at the end of the list@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac push-update ITEM PLACE &key TEST KEY
@anchor{go to the push-update macro}@c
@macrosubindex{push-update}@c
like pushnew, but if there is test-equal atom in the place, replaces it by item@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac pushnew-end ITEM LIST &key KEY TEST
@anchor{go to the pushnew-end macro}@c
@macrosubindex{pushnew-end}@c
pushes the item at the end of list, it it's not yet in the list as a second value, returns whether the list was actualy altered@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defmac
@defmac retract &rest FACT-SPECS
@anchor{go to the retract macro}@c
@macrosubindex{retract}@c
Remove fact from working memory@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac setstrategy NAME
@anchor{go to the setstrategy macro}@c
@macrosubindex{setstrategy}@c
Set strategy to use@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac undeffacts NAME
@anchor{go to the undeffacts macro}@c
@macrosubindex{undeffacts}@c
Delete fact group@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac undefrule NAME
@anchor{go to the undefrule macro}@c
@macrosubindex{undefrule}@c
Undefine rule@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac unwatch WATCHER
@anchor{go to the unwatch macro}@c
@macrosubindex{unwatch}@c
Unwatch selected item@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac
@defmac watch WATCHER
@anchor{go to the watch macro}@c
@macrosubindex{watch}@c
Watch selected item (facts, rules, activations)@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defmac

@node Exported functions, Exported generic functions, Exported macros, Exported definitions
@subsection Functions

@defun add-fact FACT
@anchor{go to the add-fact function}@c
@functionsubindex{add-fact}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun add-fact-group GROUP-NAME FACT-DESCRIPTIONS
@anchor{go to the add-fact-group function}@c
@functionsubindex{add-fact-group}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun add-rule RULE
@anchor{go to the add-rule function}@c
@functionsubindex{add-rule}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun add-template TEMPLATE
@anchor{go to the add-template function}@c
@functionsubindex{add-template}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun alistp LIST
@anchor{go to the alistp function}@c
@functionsubindex{alistp}@c
is the list an assoc-list?@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun assoc-key VALUE ALIST
@anchor{go to the assoc-key function}@c
@functionsubindex{assoc-key}@c
get key from assoc-list according to the value@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun assoc-value THE-KEY ALIST &key KEY TEST
@anchor{go to the assoc-value function}@c
@functionsubindex{assoc-value}@c
get value from assoc-list according to the key@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun (setf@ assoc-value) VALUE THE-KEY ALIST &key KEY TEST
@anchor{go to the (setf assoc-value) function}@c
@functionsubindex{(setf assoc-value)}@c
set value in assoc-list according to the key@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun class-slot-value CLASS-NAME SLOT-NAME
@anchor{go to the class-slot-value function}@c
@functionsubindex{class-slot-value}@c
get a class-slot value from class-name@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun clear 
@anchor{go to the clear function}@c
@functionsubindex{clear}@c
Delete all facts@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun constant-test DESIRED-VALUE REAL-VALUE
@anchor{go to the constant-test function}@c
@functionsubindex{constant-test}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end defun
@defun cpl-assoc-val KEY CPL-LIST
@anchor{go to the cpl-assoc-val function}@c
@functionsubindex{cpl-assoc-val}@c
@defunx (setf@ cpl-assoc-val) NEW-VAL KEY CPL-LIST
@anchor{go to the (setf cpl-assoc-val) function}@c
@functionsubindex{(setf cpl-assoc-val)}@c
get value from couple list according to the key@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun every-couple PREDICATE LIST
@anchor{go to the every-couple function}@c
@functionsubindex{every-couple}@c
applies 2-parameter predicate to every couple of items in the list, returns true if all the return values are true@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun facts &optional START-INDEX END-INDEX AT-MOST
@anchor{go to the facts function}@c
@functionsubindex{facts}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun find-fact FACT
@anchor{go to the find-fact function}@c
@functionsubindex{find-fact}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun find-rule NAME
@anchor{go to the find-rule function}@c
@functionsubindex{find-rule}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun from-keyword KEY &optional PACKAGE
@anchor{go to the from-keyword function}@c
@functionsubindex{from-keyword}@c
get sybol from key@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun halt 
@anchor{go to the halt function}@c
@functionsubindex{halt}@c
Stop the inference engine@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun intern STRING &optional PACKAGE
@anchor{go to the intern function}@c
@functionsubindex{intern}@c
create symbol from string@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun make-fact FACT-SPEC
@anchor{go to the make-fact function}@c
@functionsubindex{make-fact}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end defun
@defun make-pattern SPECIFICATION &key MATCH-VAR
@anchor{go to the make-pattern function}@c
@functionsubindex{make-pattern}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end defun
@defun make-rete 
@anchor{go to the make-rete function}@c
@functionsubindex{make-rete}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end defun
@defun make-template NAME SLOTS
@anchor{go to the make-template function}@c
@functionsubindex{make-template}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun
@defun modify-fact FACT MOD-LIST
@anchor{go to the modify-fact function}@c
@functionsubindex{modify-fact}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun plistp LIST
@anchor{go to the plistp function}@c
@functionsubindex{plistp}@c
is the list a property list?@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun rem-fact FACT
@anchor{go to the rem-fact function}@c
@functionsubindex{rem-fact}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun rem-fact-group NAME
@anchor{go to the rem-fact-group function}@c
@functionsubindex{rem-fact-group}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun rem-rule RULE
@anchor{go to the rem-rule function}@c
@functionsubindex{rem-rule}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun reset 
@anchor{go to the reset function}@c
@functionsubindex{reset}@c
Clear all facts and add all fact groups@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun reset-environment 
@anchor{go to the reset-environment function}@c
@functionsubindex{reset-environment}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun reset-facts 
@anchor{go to the reset-facts function}@c
@functionsubindex{reset-facts}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun retract-all 
@anchor{go to the retract-all function}@c
@functionsubindex{retract-all}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun run 
@anchor{go to the run function}@c
@functionsubindex{run}@c
Run the infenece engine@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun select LIST INDICES
@anchor{go to the select function}@c
@functionsubindex{select}@c
get a list of values from list according to the list of indices@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun step 
@anchor{go to the step function}@c
@functionsubindex{step}@c
Run inference engine for one turn@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun string-append &rest STRINGS
@anchor{go to the string-append function}@c
@functionsubindex{string-append}@c
append two strings@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun subsets LIST
@anchor{go to the subsets function}@c
@functionsubindex{subsets}@c
get a list of all subsets of given list@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun symbol-append &rest SYMBOLS
@anchor{go to the symbol-append function}@c
@functionsubindex{symbol-append}@c
concatenate several symbols@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun to-keyword SYMBOL
@anchor{go to the to-keyword function}@c
@functionsubindex{to-keyword}@c
get keyword form of symbol@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun to-list X
@anchor{go to the to-list function}@c
@functionsubindex{to-list}@c
when given an atom, returns list containing it, when given a list, just returns it@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun to-list-of-lists LIST
@anchor{go to the to-list-of-lists function}@c
@functionsubindex{to-list-of-lists}@c
collects return value of to-list on each element@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end defun
@defun var-or-equal-p ATOM1 ATOM2
@anchor{go to the var-or-equal-p function}@c
@functionsubindex{var-or-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end defun
@defun variable-p EXPR
@anchor{go to the variable-p function}@c
@functionsubindex{variable-p}@c
is expr an exil variable?@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun

@node Exported generic functions, Exported classes, Exported functions, Exported definitions
@subsection Generic functions

@deffn {Generic Function} activate-rule ACTIVATION
@anchor{go to the activate-rule generic function}@c
@genericsubindex{activate-rule}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} activate-rule (ACTIVATION @t{match})
@anchor{go to the activate-rule match method}@c
@methodsubindex{activate-rule}@c
@table @strong
@item Source
@ref{go to the activations.lisp file, , @t{activations}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} activations OBJECT
@anchor{go to the activations generic function}@c
@genericsubindex{activations}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} activations (RULE @t{rule})
@anchor{go to the activations rule method}@c
@methodsubindex{activations}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rules.lisp file, , @t{rules}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} add-match PRODUCTION TOKEN
@anchor{go to the add-match generic function}@c
@genericsubindex{add-match}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} add-match PRODUCTION TOKEN
@anchor{go to the add-match t t method}@c
@methodsubindex{add-match}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} add-strategy NAME FUNCTION
@anchor{go to the add-strategy generic function}@c
@genericsubindex{add-strategy}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} add-strategy NAME FUNCTION
@anchor{go to the add-strategy t t method}@c
@methodsubindex{add-strategy}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} add-wme FACT &optional RETE
@anchor{go to the add-wme generic function}@c
@genericsubindex{add-wme}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} add-wme (FACT @t{fact}) &optional RETE
@anchor{go to the add-wme fact method}@c
@methodsubindex{add-wme}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} agenda 
@anchor{go to the agenda generic function}@c
@genericsubindex{agenda}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} agenda 
@anchor{go to the agenda method}@c
@methodsubindex{agenda}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} atom-equal-p OBJECT1 OBJECT2
@anchor{go to the atom-equal-p generic function}@c
@genericsubindex{atom-equal-p}@c
equality predicate for fact atoms@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@item Methods
@deffn {Method} atom-equal-p OBJECT1 OBJECT2
@anchor{go to the atom-equal-p t t method}@c
@methodsubindex{atom-equal-p}@c
@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} atom-position OBJECT ATOM
@anchor{go to the atom-position generic function}@c
@genericsubindex{atom-position}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} atom-position (PATTERN @t{simple-pattern}) ATOM
@anchor{go to the atom-position simple-pattern t method}@c
@methodsubindex{atom-position}@c
@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@deffn {Method} atom-position (FACT @t{simple-fact}) ATOM
@anchor{go to the atom-position simple-fact t method}@c
@methodsubindex{atom-position}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@deffn {Method} atom-position (OBJECT @t{template-object}) ATOM
@anchor{go to the atom-position template-object t method}@c
@methodsubindex{atom-position}@c
get the atom position in template-object slots@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} conditions OBJECT
@anchor{go to the conditions generic function}@c
@genericsubindex{conditions}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} conditions (RULE @t{rule})
@anchor{go to the conditions rule method}@c
@methodsubindex{conditions}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rules.lisp file, , @t{rules}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} copy-fact FACT
@anchor{go to the copy-fact generic function}@c
@genericsubindex{copy-fact}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} copy-fact (FACT @t{fact})
@anchor{go to the copy-fact fact method}@c
@methodsubindex{copy-fact}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} exil-equal-p OBJ1 OBJ2
@anchor{go to the exil-equal-p generic function}@c
@genericsubindex{exil-equal-p}@c
ExiL default equality predicate@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@item Methods
@deffn {Method} exil-equal-p (OBJ1 @t{cons}) (OBJ2 @t{cons})
@anchor{go to the exil-equal-p cons cons method}@c
@methodsubindex{exil-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} exil-equal-p (OBJ1 @t{number}) (OBJ2 @t{number})
@anchor{go to the exil-equal-p number number method}@c
@methodsubindex{exil-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} exil-equal-p (OBJ1 @t{symbol}) (OBJ2 @t{symbol})
@anchor{go to the exil-equal-p symbol symbol method}@c
@methodsubindex{exil-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} exil-equal-p (OBJ1 @t{string}) (OBJ2 @t{string})
@anchor{go to the exil-equal-p string string method}@c
@methodsubindex{exil-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} exil-equal-p OBJ1 OBJ2
@anchor{go to the exil-equal-p t t method}@c
@methodsubindex{exil-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} exil-equal-p (OBJ1 @t{null}) (OBJ2 @t{null})
@anchor{go to the exil-equal-p null null method}@c
@methodsubindex{exil-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} exil-weak-equal-p OBJ1 OBJ2
@anchor{go to the exil-weak-equal-p generic function}@c
@genericsubindex{exil-weak-equal-p}@c
ExiL default weak equality predicate@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@item Methods
@deffn {Method} exil-weak-equal-p (OBJ1 @t{cons}) (OBJ2 @t{cons})
@anchor{go to the exil-weak-equal-p cons cons method}@c
@methodsubindex{exil-weak-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} exil-weak-equal-p (OBJ1 @t{symbol}) (OBJ2 @t{symbol})
@anchor{go to the exil-weak-equal-p symbol symbol method}@c
@methodsubindex{exil-weak-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} exil-weak-equal-p OBJ1 OBJ2
@anchor{go to the exil-weak-equal-p t t method}@c
@methodsubindex{exil-weak-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} fact OBJECT
@anchor{go to the fact generic function}@c
@genericsubindex{fact}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} fact (SIMPLE-FACT @t{simple-fact})
@anchor{go to the fact simple-fact method}@c
@methodsubindex{fact}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} fact-description FACT
@anchor{go to the fact-description generic function}@c
@genericsubindex{fact-description}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} fact-description (FACT @t{template-fact})
@anchor{go to the fact-description template-fact method}@c
@methodsubindex{fact-description}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@deffn {Method} fact-description (FACT @t{simple-fact})
@anchor{go to the fact-description simple-fact method}@c
@methodsubindex{fact-description}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} fact-equal-p FACT1 FACT2
@anchor{go to the fact-equal-p generic function}@c
@genericsubindex{fact-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@item Methods
@deffn {Method} fact-equal-p (FACT1 @t{template-fact}) (FACT2 @t{template-fact})
@anchor{go to the fact-equal-p template-fact template-fact method}@c
@methodsubindex{fact-equal-p}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@deffn {Method} fact-equal-p (FACT1 @t{simple-fact}) (FACT2 @t{simple-fact})
@anchor{go to the fact-equal-p simple-fact simple-fact method}@c
@methodsubindex{fact-equal-p}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@deffn {Method} fact-equal-p FACT1 FACT2
@anchor{go to the fact-equal-p t t method}@c
@methodsubindex{fact-equal-p}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} fact-groups 
@anchor{go to the fact-groups generic function}@c
@genericsubindex{fact-groups}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} fact-groups 
@anchor{go to the fact-groups method}@c
@methodsubindex{fact-groups}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} fact-slot FACT SLOT-SPEC
@anchor{go to the fact-slot generic function}@c
@genericsubindex{fact-slot}@c
returns fact's slot specified by slot-spec@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@item Methods
@deffn {Method} fact-slot (FACT @t{simple-fact}) (SLOT-SPEC @t{integer})
@anchor{go to the fact-slot simple-fact integer method}@c
@methodsubindex{fact-slot}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@deffn {Method} fact-slot (FACT @t{template-fact}) (SLOT-SPEC @t{symbol})
@anchor{go to the fact-slot template-fact symbol method}@c
@methodsubindex{fact-slot}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} facts 
@anchor{go to the facts generic function}@c
@genericsubindex{facts}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} facts 
@anchor{go to the facts method}@c
@methodsubindex{facts}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} find-atom OBJECT ATOM
@anchor{go to the find-atom generic function}@c
@genericsubindex{find-atom}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} find-atom (PATTERN @t{simple-pattern}) ATOM
@anchor{go to the find-atom simple-pattern t method}@c
@methodsubindex{find-atom}@c
@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@deffn {Method} find-atom (FACT @t{simple-fact}) ATOM
@anchor{go to the find-atom simple-fact t method}@c
@methodsubindex{find-atom}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@deffn {Method} find-atom (OBJECT @t{template-object}) ATOM
@anchor{go to the find-atom template-object t method}@c
@methodsubindex{find-atom}@c
find the given atom in template-object slots@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} find-template NAME
@anchor{go to the find-template generic function}@c
@genericsubindex{find-template}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} find-template NAME
@anchor{go to the find-template t method}@c
@methodsubindex{find-template}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} has-slot-p OBJECT SLOT-NAME
@anchor{go to the has-slot-p generic function}@c
@genericsubindex{has-slot-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} has-slot-p (OBJECT @t{template-object}) SLOT-NAME
@anchor{go to the has-slot-p template-object t method}@c
@methodsubindex{has-slot-p}@c
@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} hash->list HASH
@anchor{go to the hash->list generic function}@c
@genericsubindex{hash->list}@c
@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Methods
@deffn {Method} hash->list (HASH @t{hash-table})
@anchor{go to the hash->list hash-table method}@c
@methodsubindex{hash->list}@c
returns list of all values in the hash@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} make-rule NAME CONDITIONS ACTIVATIONS
@anchor{go to the make-rule generic function}@c
@genericsubindex{make-rule}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} make-rule NAME CONDITIONS ACTIVATIONS
@anchor{go to the make-rule t t t method}@c
@methodsubindex{make-rule}@c
@table @strong
@item Source
@ref{go to the rules.lisp file, , @t{rules}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} match-var OBJECT
@anchor{go to the match-var generic function}@c
@genericsubindex{match-var}@c
@deffnx {Generic Function} (setf@ match-var) NEW-VALUE OBJECT
@anchor{go to the (setf match-var) generic function}@c
@genericsubindex{(setf match-var)}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} match-var (PATTERN @t{pattern})
@anchor{go to the match-var pattern method}@c
@methodsubindex{match-var}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ match-var) NEW-VALUE (PATTERN @t{pattern})
@anchor{go to the (setf match-var) t pattern method}@c
@methodsubindex{(setf match-var)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} name OBJECT
@anchor{go to the name generic function}@c
@genericsubindex{name}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} name (RULE @t{rule})
@anchor{go to the name rule method}@c
@methodsubindex{name}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rules.lisp file, , @t{rules}} (Lisp file)
@end table
@end deffn
@deffn {Method} name (TEMPLATE @t{template})
@anchor{go to the name template method}@c
@methodsubindex{name}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} negated-p OBJECT
@anchor{go to the negated-p generic function}@c
@genericsubindex{negated-p}@c
@deffnx {Generic Function} (setf@ negated-p) NEW-VALUE OBJECT
@anchor{go to the (setf negated-p) generic function}@c
@genericsubindex{(setf negated-p)}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} negated-p (PATTERN @t{pattern})
@anchor{go to the negated-p pattern method}@c
@methodsubindex{negated-p}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ negated-p) NEW-VALUE (PATTERN @t{pattern})
@anchor{go to the (setf negated-p) t pattern method}@c
@methodsubindex{(setf negated-p)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} new-production RULE &optional RETE
@anchor{go to the new-production generic function}@c
@genericsubindex{new-production}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} new-production (RULE @t{rule}) &optional RETE
@anchor{go to the new-production rule method}@c
@methodsubindex{new-production}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} pattern OBJECT
@anchor{go to the pattern generic function}@c
@genericsubindex{pattern}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} pattern (SIMPLE-PATTERN @t{simple-pattern})
@anchor{go to the pattern simple-pattern method}@c
@methodsubindex{pattern}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} pattern-equal-p PATTERN1 PATTERN2
@anchor{go to the pattern-equal-p generic function}@c
@genericsubindex{pattern-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@item Methods
@deffn {Method} pattern-equal-p (PATTERN1 @t{template-pattern}) (PATTERN2 @t{template-pattern})
@anchor{go to the pattern-equal-p template-pattern template-pattern method}@c
@methodsubindex{pattern-equal-p}@c
@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@deffn {Method} pattern-equal-p (PATTERN1 @t{simple-pattern}) (PATTERN2 @t{simple-pattern})
@anchor{go to the pattern-equal-p simple-pattern simple-pattern method}@c
@methodsubindex{pattern-equal-p}@c
@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@deffn {Method} pattern-equal-p (PATTERN1 @t{pattern}) (PATTERN2 @t{pattern})
@anchor{go to the pattern-equal-p pattern pattern method}@c
@methodsubindex{pattern-equal-p}@c
@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} rem-wme FACT &optional RETE
@anchor{go to the rem-wme generic function}@c
@genericsubindex{rem-wme}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} rem-wme (FACT @t{fact}) &optional RETE
@anchor{go to the rem-wme fact method}@c
@methodsubindex{rem-wme}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} remove-match PRODUCTION TOKEN
@anchor{go to the remove-match generic function}@c
@genericsubindex{remove-match}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} remove-match PRODUCTION TOKEN
@anchor{go to the remove-match t t method}@c
@methodsubindex{remove-match}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} remove-production RULE &optional RETE
@anchor{go to the remove-production generic function}@c
@genericsubindex{remove-production}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} remove-production (RULE @t{rule}) &optional RETE
@anchor{go to the remove-production rule method}@c
@methodsubindex{remove-production}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} rete 
@anchor{go to the rete generic function}@c
@genericsubindex{rete}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} rete 
@anchor{go to the rete method}@c
@methodsubindex{rete}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} rule-equal-p RULE1 RULE2
@anchor{go to the rule-equal-p generic function}@c
@genericsubindex{rule-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} rule-equal-p (RULE1 @t{rule}) (RULE2 @t{rule})
@anchor{go to the rule-equal-p rule rule method}@c
@methodsubindex{rule-equal-p}@c
@table @strong
@item Source
@ref{go to the rules.lisp file, , @t{rules}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} rules 
@anchor{go to the rules generic function}@c
@genericsubindex{rules}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} rules 
@anchor{go to the rules method}@c
@methodsubindex{rules}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} select-activation 
@anchor{go to the select-activation generic function}@c
@genericsubindex{select-activation}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} select-activation 
@anchor{go to the select-activation method}@c
@methodsubindex{select-activation}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} set-strategy &optional NAME
@anchor{go to the set-strategy generic function}@c
@genericsubindex{set-strategy}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} set-strategy &optional NAME
@anchor{go to the set-strategy method}@c
@methodsubindex{set-strategy}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} set-watcher WATCHER
@anchor{go to the set-watcher generic function}@c
@genericsubindex{set-watcher}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} set-watcher WATCHER
@anchor{go to the set-watcher t method}@c
@methodsubindex{set-watcher}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} slots OBJECT
@anchor{go to the slots generic function}@c
@genericsubindex{slots}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} slots (TEMPLATE-OBJECT @t{template-object})
@anchor{go to the slots template-object method}@c
@methodsubindex{slots}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@deffn {Method} slots (TEMPLATE @t{template})
@anchor{go to the slots template method}@c
@methodsubindex{slots}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} symbol-name SYMBOL
@anchor{go to the symbol-name generic function}@c
@genericsubindex{symbol-name}@c
For symbol return its name, for string just return itself@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@item Methods
@deffn {Method} symbol-name (SYMBOL @t{symbol})
@anchor{go to the symbol-name symbol method}@c
@methodsubindex{symbol-name}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} symbol-name (STRING @t{string})
@anchor{go to the symbol-name string method}@c
@methodsubindex{symbol-name}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} templates 
@anchor{go to the templates generic function}@c
@genericsubindex{templates}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} templates 
@anchor{go to the templates method}@c
@methodsubindex{templates}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tmpl-fact-slot-value FACT SLOT-NAME
@anchor{go to the tmpl-fact-slot-value generic function}@c
@genericsubindex{tmpl-fact-slot-value}@c
@deffnx {Generic Function} (setf@ tmpl-fact-slot-value) VAL FACT SLOT-NAME
@anchor{go to the (setf tmpl-fact-slot-value) generic function}@c
@genericsubindex{(setf tmpl-fact-slot-value)}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} tmpl-fact-slot-value (FACT @t{template-fact}) SLOT-NAME
@anchor{go to the tmpl-fact-slot-value template-fact t method}@c
@methodsubindex{tmpl-fact-slot-value}@c
@deffnx {Method} (setf@ tmpl-fact-slot-value) VAL (FACT @t{template-fact}) SLOT-NAME

@anchor{go to the (setf tmpl-fact-slot-value) t template-fact t method}@c
@methodsubindex{(setf tmpl-fact-slot-value)}@c
@table @strong
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tmpl-name OBJECT
@anchor{go to the tmpl-name generic function}@c
@genericsubindex{tmpl-name}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} tmpl-name (TEMPLATE-OBJECT @t{template-object})
@anchor{go to the tmpl-name template-object method}@c
@methodsubindex{tmpl-name}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} token->list TOKEN
@anchor{go to the token->list generic function}@c
@genericsubindex{token->list}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} token->list (TOKEN @t{token})
@anchor{go to the token->list token method}@c
@methodsubindex{token->list}@c
@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} token-equal-p TOKEN1 TOKEN2
@anchor{go to the token-equal-p generic function}@c
@genericsubindex{token-equal-p}@c
token equality predicate@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@item Methods
@deffn {Method} token-equal-p TOKEN1 TOKEN2
@anchor{go to the token-equal-p t t method}@c
@methodsubindex{token-equal-p}@c
@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@deffn {Method} token-equal-p (TOKEN1 @t{empty-token}) (TOKEN2 @t{empty-token})
@anchor{go to the token-equal-p empty-token empty-token method}@c
@methodsubindex{token-equal-p}@c
@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@deffn {Method} token-equal-p (TOKEN1 @t{token}) (TOKEN2 @t{token})
@anchor{go to the token-equal-p token token method}@c
@methodsubindex{token-equal-p}@c
@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} unset-watcher WATCHER
@anchor{go to the unset-watcher generic function}@c
@genericsubindex{unset-watcher}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} unset-watcher WATCHER
@anchor{go to the unset-watcher t method}@c
@methodsubindex{unset-watcher}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} unwatch-all 
@anchor{go to the unwatch-all generic function}@c
@genericsubindex{unwatch-all}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} unwatch-all 
@anchor{go to the unwatch-all method}@c
@methodsubindex{unwatch-all}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} watch-all 
@anchor{go to the watch-all generic function}@c
@genericsubindex{watch-all}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} watch-all 
@anchor{go to the watch-all method}@c
@methodsubindex{watch-all}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} watched-p WATCHER
@anchor{go to the watched-p generic function}@c
@genericsubindex{watched-p}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} watched-p WATCHER
@anchor{go to the watched-p t method}@c
@methodsubindex{watched-p}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} weak-symbol-equal-p SYM1 SYM2
@anchor{go to the weak-symbol-equal-p generic function}@c
@genericsubindex{weak-symbol-equal-p}@c
test if the symbol name is equal, omits the package name@table @strong
@item Package
@ref{go to the exil-utils package, , @t{exil-utils}}
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@item Methods
@deffn {Method} weak-symbol-equal-p (SYM1 @t{symbol}) (SYM2 @t{symbol})
@anchor{go to the weak-symbol-equal-p symbol symbol method}@c
@methodsubindex{weak-symbol-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@deffn {Method} weak-symbol-equal-p SYM1 SYM2
@anchor{go to the weak-symbol-equal-p t t method}@c
@methodsubindex{weak-symbol-equal-p}@c
@table @strong
@item Source
@ref{go to the utils.lisp file, , @t{utils}} (Lisp file)
@end table
@end deffn
@end table
@end deffn

@node Exported classes, , Exported generic functions, Exported definitions
@subsection Classes

@deftp {Class} fact
@anchor{go to the fact class}@c
@classsubindex{fact}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the simple-fact class, , @t{simple-fact}} (class)
@item
@ref{go to the template-fact class, , @t{template-fact}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the rem-wme fact method, , @t{rem-wme}} (method)
@item
@ref{go to the add-wme fact method, , @t{add-wme}} (method)
@item
@ref{go to the inactivate beta-negative-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the activate beta-negative-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate beta-join-node fact method, , @t{activate}} (method)
@item
@ref{go to the perform-join-tests list token fact method, , @t{perform-join-tests}} (method)
@item
@ref{go to the perform-join-test test token fact method, , @t{perform-join-test}} (method)
@item
@ref{go to the inactivate beta-memory-node fact before method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate alpha-memory-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the activate alpha-memory-node fact method, , @t{activate}} (method)
@item
@ref{go to the inactivate alpha-top-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the activate alpha-top-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate alpha-subtop-node fact method, , @t{activate}} (method)
@item
@ref{go to the inactivate alpha-test-node fact after method, , @t{inactivate}} (method)
@item
@ref{go to the activate alpha-test-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate-memory alpha-test-node fact method, , @t{activate-memory}} (method)
@item
@ref{go to the activate-children alpha-test-node fact method, , @t{activate-children}} (method)
@item
@ref{go to the test alpha-test-node fact method, , @t{test}} (method)
@item
@ref{go to the includes-p fact token method, , @t{includes-p}} (method)
@item
@ref{go to the copy-fact fact method, , @t{copy-fact}} (method)
@end itemize
@end table
@end deftp
@deftp {Class} pattern
@anchor{go to the pattern class}@c
@classsubindex{pattern}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the simple-pattern class, , @t{simple-pattern}} (class)
@item
@ref{go to the template-pattern class, , @t{template-pattern}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the get-join-tests-from-condition pattern list method, , @t{get-join-tests-from-condition}} (method)
@item
@ref{go to the pattern-equal-p pattern pattern method, , @t{pattern-equal-p}} (method)
@item
@t{match-var}
@item
@ref{go to the match-var pattern method, , @t{match-var}} (method)
@item
@t{negated-p}
@item
@ref{go to the negated-p pattern method, , @t{negated-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} negated
@slotsubindex{negated}@c
@table @strong
@item Initargs
@t{:negated}
@item Readers
@ref{go to the negated-p generic function, , @t{negated-p}} (generic function)
@item Writers
@ref{go to the (setf negated-p) generic function, , @t{(setf negated-p)}} (generic function)
@end table
@end defvr
@defvr {Slot} match-variable
@slotsubindex{match-variable}@c
@table @strong
@item Initargs
@t{:match-var}
@item Readers
@ref{go to the match-var generic function, , @t{match-var}} (generic function)
@item Writers
@ref{go to the (setf match-var) generic function, , @t{(setf match-var)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} rule
@anchor{go to the rule class}@c
@classsubindex{rule}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the rules.lisp file, , @t{rules}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct methods
@itemize @bullet
@item
@ref{go to the simpler-than rule rule method, , @t{simpler-than}} (method)
@item
@ref{go to the remove-production rule method, , @t{remove-production}} (method)
@item
@ref{go to the new-production rule method, , @t{new-production}} (method)
@item
@ref{go to the delete-production beta-memory-node rule method, , @t{delete-production}} (method)
@item
@ref{go to the add-production beta-memory-node rule method, , @t{add-production}} (method)
@item
@t{print-object}
@item
@ref{go to the rule-equal-p rule rule method, , @t{rule-equal-p}} (method)
@item
@ref{go to the activations rule method, , @t{activations}} (method)
@item
@ref{go to the conditions rule method, , @t{conditions}} (method)
@item
@ref{go to the name rule method, , @t{name}} (method)
@end itemize
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@item Readers
@ref{go to the name generic function, , @t{name}} (generic function)
@end table
@end defvr
@defvr {Slot} conditions
@slotsubindex{conditions}@c
@table @strong
@item Initargs
@t{:conditions}
@item Readers
@ref{go to the conditions generic function, , @t{conditions}} (generic function)
@end table
@end defvr
@defvr {Slot} activations
@slotsubindex{activations}@c
@table @strong
@item Initargs
@t{:activations}
@item Readers
@ref{go to the activations generic function, , @t{activations}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} simple-fact
@anchor{go to the simple-fact class}@c
@classsubindex{simple-fact}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@item Direct superclasses
@ref{go to the fact class, , @t{fact}} (class)
@item Direct methods
@itemize @bullet
@item
@ref{go to the variable-bindings simple-pattern simple-fact method, , @t{variable-bindings}} (method)
@item
@ref{go to the test simple-fact-test-node simple-fact method, , @t{test}} (method)
@item
@ref{go to the fact-slot simple-fact integer method, , @t{fact-slot}} (method)
@item
@ref{go to the fact-description simple-fact method, , @t{fact-description}} (method)
@item
@ref{go to the atom-position simple-fact t method, , @t{atom-position}} (method)
@item
@ref{go to the find-atom simple-fact t method, , @t{find-atom}} (method)
@item
@ref{go to the fact-equal-p simple-fact simple-fact method, , @t{fact-equal-p}} (method)
@item
@t{print-object}
@item
@t{initialize-instance}
@item
@ref{go to the fact simple-fact method, , @t{fact}} (method)
@end itemize
@item Direct slots
@defvr {Slot} fact
@slotsubindex{fact}@c
@table @strong
@item Initargs
@t{:fact}
@item Initform
@t{(error "fact slot must be specified")}
@item Readers
@ref{go to the fact generic function, , @t{fact}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} simple-pattern
@anchor{go to the simple-pattern class}@c
@classsubindex{simple-pattern}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@item Direct superclasses
@ref{go to the pattern class, , @t{pattern}} (class)
@item Direct methods
@itemize @bullet
@item
@ref{go to the variable-bindings simple-pattern simple-fact method, , @t{variable-bindings}} (method)
@item
@ref{go to the get-intracondition-tests% simple-pattern method, , @t{get-intracondition-tests%}} (method)
@item
@ref{go to the get-intercondition-tests% simple-pattern list method, , @t{get-intercondition-tests%}} (method)
@item
@ref{go to the create-alpha-net simple-pattern method, , @t{create-alpha-net}} (method)
@item
@ref{go to the create-alpha-net% simple-pattern simple-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@item
@ref{go to the atom-position simple-pattern t method, , @t{atom-position}} (method)
@item
@ref{go to the find-atom simple-pattern t method, , @t{find-atom}} (method)
@item
@ref{go to the pattern-equal-p simple-pattern simple-pattern method, , @t{pattern-equal-p}} (method)
@item
@t{print-object}
@item
@ref{go to the pattern simple-pattern method, , @t{pattern}} (method)
@end itemize
@item Direct slots
@defvr {Slot} pattern
@slotsubindex{pattern}@c
@table @strong
@item Initargs
@t{:pattern}
@item Initform
@t{(error "pattern slot must be specified")}
@item Readers
@ref{go to the pattern generic function, , @t{pattern}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} template
@anchor{go to the template class}@c
@classsubindex{template}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct methods
@itemize @bullet
@item
@t{print-object}
@item
@ref{go to the slots template method, , @t{slots}} (method)
@item
@ref{go to the name template method, , @t{name}} (method)
@end itemize
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@item Initform
@t{(error "name slot has to be specified")}
@item Readers
@ref{go to the name generic function, , @t{name}} (generic function)
@end table
@end defvr
@defvr {Slot} slots
@slotsubindex{slots}@c
@table @strong
@item Initargs
@t{:slots}
@item Initform
@t{(error "slots slot has to be specified")}
@item Readers
@ref{go to the slots generic function, , @t{slots}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} template-fact
@anchor{go to the template-fact class}@c
@classsubindex{template-fact}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the template-object class, , @t{template-object}} (class)
@item
@ref{go to the fact class, , @t{fact}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the variable-bindings template-pattern template-fact method, , @t{variable-bindings}} (method)
@item
@ref{go to the test template-fact-test-node template-fact method, , @t{test}} (method)
@item
@ref{go to the fact-slot template-fact symbol method, , @t{fact-slot}} (method)
@item
@ref{go to the fact-description template-fact method, , @t{fact-description}} (method)
@item
@ref{go to the fact-equal-p template-fact template-fact method, , @t{fact-equal-p}} (method)
@item
@t{tmpl-fact-slot-value}
@item
@ref{go to the tmpl-fact-slot-value template-fact t method, , @t{tmpl-fact-slot-value}} (method)
@item
@t{initialize-instance}
@end itemize
@end table
@end deftp
@deftp {Class} template-pattern
@anchor{go to the template-pattern class}@c
@classsubindex{template-pattern}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the template-object class, , @t{template-object}} (class)
@item
@ref{go to the pattern class, , @t{pattern}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the variable-bindings template-pattern template-fact method, , @t{variable-bindings}} (method)
@item
@ref{go to the get-intracondition-tests% template-pattern method, , @t{get-intracondition-tests%}} (method)
@item
@ref{go to the get-intercondition-tests% template-pattern list method, , @t{get-intercondition-tests%}} (method)
@item
@ref{go to the create-alpha-net template-pattern method, , @t{create-alpha-net}} (method)
@item
@ref{go to the create-alpha-net% template-pattern template-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@item
@t{print-object}
@item
@ref{go to the pattern-equal-p template-pattern template-pattern method, , @t{pattern-equal-p}} (method)
@item
@ref{go to the tmpl-pattern-slot-value template-pattern t method, , @t{tmpl-pattern-slot-value}} (method)
@end itemize
@item Direct slots
@defvr {Slot} slot-default
@slotsubindex{slot-default}@c
@table @strong
@item Allocation
@t{:class}
@item Initform
@t{'exil-core::?}
@end table
@end defvr
@end table
@end deftp


@c --------------------
@c Internal definitions
@c --------------------
@node Internal definitions, , Exported definitions, Definitions
@section Internal definitions

@menu
* Internal special variables::
* Internal macros::
* Internal functions::
* Internal generic functions::
* Internal classes::
@end menu

@node Internal special variables, Internal macros, Internal definitions, Internal definitions
@subsection Special variables

@defvr {Special Variable} *clips-mode*
@anchor{go to the *clips-mode* special variable}@c
@specialsubindex{*clips-mode*}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defvr
@defvr {Special Variable} *current-environment*
@anchor{go to the *current-environment* special variable}@c
@specialsubindex{*current-environment*}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defvr
@defvr {Special Variable} *environments*
@anchor{go to the *environments* special variable}@c
@specialsubindex{*environments*}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defvr
@defvr {Special Variable} *exil-running*
@anchor{go to the *exil-running* special variable}@c
@specialsubindex{*exil-running*}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defvr

@node Internal macros, Internal functions, Internal special variables, Internal definitions
@subsection Macros

@defmac defenv NAME &key REDEFINE
@anchor{go to the defenv macro}@c
@macrosubindex{defenv}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defmac
@defmac exil-env-accessor SLOT-NAME
@anchor{go to the exil-env-accessor macro}@c
@macrosubindex{exil-env-accessor}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defmac
@defmac exil-env-accessors &rest SLOT-NAMES
@anchor{go to the exil-env-accessors macro}@c
@macrosubindex{exil-env-accessors}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defmac
@defmac exil-env-reader SLOT-NAME
@anchor{go to the exil-env-reader macro}@c
@macrosubindex{exil-env-reader}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defmac
@defmac exil-env-writer SLOT-NAME
@anchor{go to the exil-env-writer macro}@c
@macrosubindex{exil-env-writer}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defmac
@defmac setenv NAME
@anchor{go to the setenv macro}@c
@macrosubindex{setenv}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defmac

@node Internal functions, Internal generic functions, Internal macros, Internal definitions
@subsection Functions

@defun assert% FACT-SPEC
@anchor{go to the assert% function}@c
@functionsubindex{assert%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun assert-group% FACT-DESCRIPTIONS
@anchor{go to the assert-group% function}@c
@functionsubindex{assert-group%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun breadth-strategy AGENDA
@anchor{go to the breadth-strategy function}@c
@functionsubindex{breadth-strategy}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@end table
@end defun
@defun clips->nonclips-mod-list MOD-LIST
@anchor{go to the clips->nonclips-mod-list function}@c
@functionsubindex{clips->nonclips-mod-list}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun clips-mod-list-p MOD-LIST
@anchor{go to the clips-mod-list-p function}@c
@functionsubindex{clips-mod-list-p}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun clips-slot->slot-des% SLOT-SPEC
@anchor{go to the clips-slot->slot-des% function}@c
@functionsubindex{clips-slot->slot-des%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun clips-slot-spec-p SLOT-SPEC
@anchor{go to the clips-slot-spec-p function}@c
@functionsubindex{clips-slot-spec-p}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun clips-tmpl-slot-spec-p SPECIFICATION
@anchor{go to the clips-tmpl-slot-spec-p function}@c
@functionsubindex{clips-tmpl-slot-spec-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun
@defun completely-reset-environment 
@anchor{go to the completely-reset-environment function}@c
@functionsubindex{completely-reset-environment}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end defun
@defun complexity-strategy AGENDA
@anchor{go to the complexity-strategy function}@c
@functionsubindex{complexity-strategy}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@end table
@end defun
@defun depth-strategy AGENDA
@anchor{go to the depth-strategy function}@c
@functionsubindex{depth-strategy}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@end table
@end defun
@defun extract-conditions% COND-LIST
@anchor{go to the extract-conditions% function}@c
@functionsubindex{extract-conditions%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun find-atom-in-cond-list% ATOM COND-LIST
@anchor{go to the find-atom-in-cond-list% function}@c
@functionsubindex{find-atom-in-cond-list%}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end defun
@defun get-variable-bindings PATTERN-LIST FACT-LIST
@anchor{go to the get-variable-bindings function}@c
@functionsubindex{get-variable-bindings}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the activations.lisp file, , @t{activations}} (Lisp file)
@end table
@end defun
@defun make-match RULE TOKEN &optional TIMESTAMP
@anchor{go to the make-match function}@c
@functionsubindex{make-match}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the matches.lisp file, , @t{matches}} (Lisp file)
@end table
@end defun
@defun make-test CURRENT-FIELD PREVIOUS-CONDITION PREVIOUS-FIELD
@anchor{go to the make-test function}@c
@functionsubindex{make-test}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end defun
@defun make-tmpl-fact FACT-SPEC
@anchor{go to the make-tmpl-fact function}@c
@functionsubindex{make-tmpl-fact}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end defun
@defun make-tmpl-obj-clips OBJECT-TYPE TEMPLATE SLOT-SPECS
@anchor{go to the make-tmpl-obj-clips function}@c
@functionsubindex{make-tmpl-obj-clips}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun
@defun make-tmpl-obj-nonclips OBJECT-TYPE TEMPLATE SLOT-SPECS
@anchor{go to the make-tmpl-obj-nonclips function}@c
@functionsubindex{make-tmpl-obj-nonclips}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun
@defun make-tmpl-object SPECIFICATION OBJECT-TYPE
@anchor{go to the make-tmpl-object function}@c
@functionsubindex{make-tmpl-object}@c
creates template-object of given type from its specification@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun
@defun make-tmpl-pattern PATTERN-SPEC &optional NEGATED MATCH-VAR
@anchor{go to the make-tmpl-pattern function}@c
@functionsubindex{make-tmpl-pattern}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end defun
@defun my-position ATOM LIST
@anchor{go to the my-position function}@c
@functionsubindex{my-position}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun nonclips-mod-list-p MOD-LIST
@anchor{go to the nonclips-mod-list-p function}@c
@functionsubindex{nonclips-mod-list-p}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun nonclips-slot->slot-des% SLOT-SPEC
@anchor{go to the nonclips-slot->slot-des% function}@c
@functionsubindex{nonclips-slot->slot-des%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun nonclips-slot-spec-p SLOT-SPEC
@anchor{go to the nonclips-slot-spec-p function}@c
@functionsubindex{nonclips-slot-spec-p}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun ppdefrule% NAME
@anchor{go to the ppdefrule% function}@c
@functionsubindex{ppdefrule%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun retract% FACT-SPECS
@anchor{go to the retract% function}@c
@functionsubindex{retract%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun set-clips-mode VAL
@anchor{go to the set-clips-mode function}@c
@functionsubindex{set-clips-mode}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun simplicity-strategy AGENDA
@anchor{go to the simplicity-strategy function}@c
@functionsubindex{simplicity-strategy}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@end table
@end defun
@defun slot->slot-designator% SLOT-SPEC
@anchor{go to the slot->slot-designator% function}@c
@functionsubindex{slot->slot-designator%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun slot-spec-p SLOT-SPEC
@anchor{go to the slot-spec-p function}@c
@functionsubindex{slot-spec-p}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun slots->slot-designators% SLOTS
@anchor{go to the slots->slot-designators% function}@c
@functionsubindex{slots->slot-designators%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun
@defun substitute-variables ACTIVATIONS-WITH-VARS VAR-BIND-LIST
@anchor{go to the substitute-variables function}@c
@functionsubindex{substitute-variables}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the activations.lisp file, , @t{activations}} (Lisp file)
@end table
@end defun
@defun tmpl-fact-specification-p FACT-SPEC
@anchor{go to the tmpl-fact-specification-p function}@c
@functionsubindex{tmpl-fact-specification-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the facts.lisp file, , @t{facts}} (Lisp file)
@end table
@end defun
@defun tmpl-object-specification-p SPECIFICATION
@anchor{go to the tmpl-object-specification-p function}@c
@functionsubindex{tmpl-object-specification-p}@c
is this a template-object specification?@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun
@defun tmpl-pattern-specification-p SPECIFICATION
@anchor{go to the tmpl-pattern-specification-p function}@c
@functionsubindex{tmpl-pattern-specification-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end defun
@defun tmpl-slot-spec-p SPECIFICATION
@anchor{go to the tmpl-slot-spec-p function}@c
@functionsubindex{tmpl-slot-spec-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end defun
@defun to-mod-spec-list MOD-LIST
@anchor{go to the to-mod-spec-list function}@c
@functionsubindex{to-mod-spec-list}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end defun

@node Internal generic functions, Internal classes, Internal functions, Internal definitions
@subsection Generic functions

@deffn {Generic Function} activate NODE OBJECT
@anchor{go to the activate generic function}@c
@genericsubindex{activate}@c
handels various node activations@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item Methods
@deffn {Method} activate (NODE @t{beta-negative-node}) (WME @t{fact})
@anchor{go to the activate beta-negative-node fact method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{beta-negative-node}) (TOKEN @t{token})
@anchor{go to the activate beta-negative-node token method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{beta-join-node}) (WME @t{fact})
@anchor{go to the activate beta-join-node fact method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{beta-join-node}) (TOKEN @t{token})
@anchor{go to the activate beta-join-node token method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{beta-memory-node}) (TOKEN @t{token})
@anchor{go to the activate beta-memory-node token method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{alpha-memory-node}) (WME @t{fact})
@anchor{go to the activate alpha-memory-node fact method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{alpha-top-node}) (WME @t{fact})
@anchor{go to the activate alpha-top-node fact method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{alpha-subtop-node}) (WME @t{fact})
@anchor{go to the activate alpha-subtop-node fact method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate (NODE @t{alpha-test-node}) (WME @t{fact})
@anchor{go to the activate alpha-test-node fact method}@c
@methodsubindex{activate}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} activate-children NODE OBJECT
@anchor{go to the activate-children generic function}@c
@genericsubindex{activate-children}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item Methods
@deffn {Method} activate-children (NODE @t{alpha-test-node}) (WME @t{fact})
@anchor{go to the activate-children alpha-test-node fact method}@c
@methodsubindex{activate-children}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} activate-children (NODE @t{node}) OBJECT
@anchor{go to the activate-children node t method}@c
@methodsubindex{activate-children}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} activate-memory NODE WME
@anchor{go to the activate-memory generic function}@c
@genericsubindex{activate-memory}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} activate-memory (NODE @t{alpha-test-node}) (WME @t{fact})
@anchor{go to the activate-memory alpha-test-node fact method}@c
@methodsubindex{activate-memory}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} add-child NODE CHILD
@anchor{go to the add-child generic function}@c
@genericsubindex{add-child}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} add-child (NODE @t{node}) (CHILD @t{node})
@anchor{go to the add-child node node method}@c
@methodsubindex{add-child}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} add-children NODE CHILDREN
@anchor{go to the add-children generic function}@c
@genericsubindex{add-children}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} add-children (NODE @t{node}) (CHILDREN @t{list})
@anchor{go to the add-children node list method}@c
@methodsubindex{add-children}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} add-item NODE ITEM &optional EQUALITY-PREDICATE
@anchor{go to the add-item generic function}@c
@genericsubindex{add-item}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} add-item (NODE @t{memory-node}) ITEM &optional EQUALITY-PREDICATE
@anchor{go to the add-item memory-node t method}@c
@methodsubindex{add-item}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} add-production NODE PRODUCTION
@anchor{go to the add-production generic function}@c
@genericsubindex{add-production}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} add-production (NODE @t{beta-memory-node}) (PRODUCTION @t{rule})
@anchor{go to the add-production beta-memory-node rule method}@c
@methodsubindex{add-production}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} alpha-memory OBJECT
@anchor{go to the alpha-memory generic function}@c
@genericsubindex{alpha-memory}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} alpha-memory (BETA-JOIN-NODE @t{beta-join-node})
@anchor{go to the alpha-memory beta-join-node method}@c
@methodsubindex{alpha-memory}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} alpha-top-node OBJECT
@anchor{go to the alpha-top-node generic function}@c
@genericsubindex{alpha-top-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} alpha-top-node (RETE @t{rete})
@anchor{go to the alpha-top-node rete method}@c
@methodsubindex{alpha-top-node}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} beta-memory NODE
@anchor{go to the beta-memory generic function}@c
@genericsubindex{beta-memory}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} beta-memory (NODE @t{beta-join-node})
@anchor{go to the beta-memory beta-join-node method}@c
@methodsubindex{beta-memory}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} beta-top-node OBJECT
@anchor{go to the beta-top-node generic function}@c
@genericsubindex{beta-top-node}@c
@deffnx {Generic Function} (setf@ beta-top-node) NEW-VALUE OBJECT
@anchor{go to the (setf beta-top-node) generic function}@c
@genericsubindex{(setf beta-top-node)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} beta-top-node (RETE @t{rete})
@anchor{go to the beta-top-node rete method}@c
@methodsubindex{beta-top-node}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ beta-top-node) NEW-VALUE (RETE @t{rete})
@anchor{go to the (setf beta-top-node) t rete method}@c
@methodsubindex{(setf beta-top-node)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} broken-match NODE TOKEN
@anchor{go to the broken-match generic function}@c
@genericsubindex{broken-match}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} broken-match (NODE @t{beta-memory-node}) (TOKEN @t{token})
@anchor{go to the broken-match beta-memory-node token method}@c
@methodsubindex{broken-match}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} children OBJECT
@anchor{go to the children generic function}@c
@genericsubindex{children}@c
@deffnx {Generic Function} (setf@ children) NEW-VALUE OBJECT
@anchor{go to the (setf children) generic function}@c
@genericsubindex{(setf children)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} children (NODE @t{node})
@anchor{go to the children node method}@c
@methodsubindex{children}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ children) NEW-VALUE (NODE @t{node})
@anchor{go to the (setf children) t node method}@c
@methodsubindex{(setf children)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} complete-match NODE TOKEN
@anchor{go to the complete-match generic function}@c
@genericsubindex{complete-match}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} complete-match (NODE @t{beta-memory-node}) (TOKEN @t{token})
@anchor{go to the complete-match beta-memory-node token method}@c
@methodsubindex{complete-match}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} create-alpha-net PATTERN &optional RETE
@anchor{go to the create-alpha-net generic function}@c
@genericsubindex{create-alpha-net}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} create-alpha-net (PATTERN @t{template-pattern}) &optional RETE
@anchor{go to the create-alpha-net template-pattern method}@c
@methodsubindex{create-alpha-net}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@deffn {Method} create-alpha-net (PATTERN @t{simple-pattern}) &optional RETE
@anchor{go to the create-alpha-net simple-pattern method}@c
@methodsubindex{create-alpha-net}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} create-alpha-net% PATTERN ROOT
@anchor{go to the create-alpha-net% generic function}@c
@genericsubindex{create-alpha-net%}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} create-alpha-net% (PATTERN @t{template-pattern}) (ROOT @t{template-fact-subtop-node})
@anchor{go to the create-alpha-net% template-pattern template-fact-subtop-node method}@c
@methodsubindex{create-alpha-net%}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@deffn {Method} create-alpha-net% (PATTERN @t{simple-pattern}) (ROOT @t{simple-fact-subtop-node})
@anchor{go to the create-alpha-net% simple-pattern simple-fact-subtop-node method}@c
@methodsubindex{create-alpha-net%}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} current-field OBJECT
@anchor{go to the current-field generic function}@c
@genericsubindex{current-field}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} current-field (TEST @t{test})
@anchor{go to the current-field test method}@c
@methodsubindex{current-field}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} current-strategy 
@anchor{go to the current-strategy generic function}@c
@genericsubindex{current-strategy}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} current-strategy 
@anchor{go to the current-strategy method}@c
@methodsubindex{current-strategy}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} current-strategy-name 
@anchor{go to the current-strategy-name generic function}@c
@genericsubindex{current-strategy-name}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} current-strategy-name 
@anchor{go to the current-strategy-name method}@c
@methodsubindex{current-strategy-name}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} delete-production NODE PRODUCTION
@anchor{go to the delete-production generic function}@c
@genericsubindex{delete-production}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} delete-production (NODE @t{beta-memory-node}) (PRODUCTION @t{rule})
@anchor{go to the delete-production beta-memory-node rule method}@c
@methodsubindex{delete-production}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} description OBJECT
@anchor{go to the description generic function}@c
@genericsubindex{description}@c
@deffnx {Generic Function} (setf@ description) NEW-VALUE OBJECT
@anchor{go to the (setf description) generic function}@c
@genericsubindex{(setf description)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} description (DESCRIBED-OBJECT @t{described-object})
@anchor{go to the description described-object method}@c
@methodsubindex{description}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ description) NEW-VALUE (DESCRIBED-OBJECT @t{described-object})
@anchor{go to the (setf description) t described-object method}@c
@methodsubindex{(setf description)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} find-test-node PARENT FIELD VALUE
@anchor{go to the find-test-node generic function}@c
@genericsubindex{find-test-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} find-test-node (PARENT @t{alpha-node}) FIELD VALUE
@anchor{go to the find-test-node alpha-node t t method}@c
@methodsubindex{find-test-node}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} find/create-join-node PARENT TESTS A-MEMORY
@anchor{go to the find/create-join-node generic function}@c
@genericsubindex{find/create-join-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} find/create-join-node (PARENT @t{beta-memory-node}) (TESTS @t{list}) (A-MEMORY @t{alpha-memory-node})
@anchor{go to the find/create-join-node beta-memory-node list alpha-memory-node method}@c
@methodsubindex{find/create-join-node}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} find/create-neg-node PARENT TESTS A-MEMORY
@anchor{go to the find/create-neg-node generic function}@c
@genericsubindex{find/create-neg-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} find/create-neg-node (PARENT @t{beta-memory-node}) (TESTS @t{list}) (A-MEMORY @t{alpha-memory-node})
@anchor{go to the find/create-neg-node beta-memory-node list alpha-memory-node method}@c
@methodsubindex{find/create-neg-node}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} find/create-test-node PARENT FIELD VALUE
@anchor{go to the find/create-test-node generic function}@c
@genericsubindex{find/create-test-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@item Methods
@deffn {Method} find/create-test-node (PARENT @t{simple-fact-alpha-node}) FIELD VALUE
@anchor{go to the find/create-test-node simple-fact-alpha-node t t method}@c
@methodsubindex{find/create-test-node}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@deffn {Method} find/create-test-node (PARENT @t{template-fact-alpha-node}) FIELD VALUE
@anchor{go to the find/create-test-node template-fact-alpha-node t t method}@c
@methodsubindex{find/create-test-node}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} find/create-test-node% PARENT FIELD VALUE NEW-NODE-TYPE
@anchor{go to the find/create-test-node% generic function}@c
@genericsubindex{find/create-test-node%}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} find/create-test-node% PARENT FIELD VALUE NEW-NODE-TYPE
@anchor{go to the find/create-test-node% t t t t method}@c
@methodsubindex{find/create-test-node%}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} get-bad-wmes NODE TOKEN
@anchor{go to the get-bad-wmes generic function}@c
@genericsubindex{get-bad-wmes}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} get-bad-wmes (NODE @t{beta-negative-node}) (TOKEN @t{token})
@anchor{go to the get-bad-wmes beta-negative-node token method}@c
@methodsubindex{get-bad-wmes}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} get-intercondition-tests% CONDITION PREV-CONDS
@anchor{go to the get-intercondition-tests% generic function}@c
@genericsubindex{get-intercondition-tests%}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} get-intercondition-tests% (CONDITION @t{template-pattern}) (PREV-CONDS @t{list})
@anchor{go to the get-intercondition-tests% template-pattern list method}@c
@methodsubindex{get-intercondition-tests%}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@deffn {Method} get-intercondition-tests% (CONDITION @t{simple-pattern}) (PREV-CONDS @t{list})
@anchor{go to the get-intercondition-tests% simple-pattern list method}@c
@methodsubindex{get-intercondition-tests%}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} get-intracondition-tests% CONDITION
@anchor{go to the get-intracondition-tests% generic function}@c
@genericsubindex{get-intracondition-tests%}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} get-intracondition-tests% (CONDITION @t{template-pattern})
@anchor{go to the get-intracondition-tests% template-pattern method}@c
@methodsubindex{get-intracondition-tests%}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@deffn {Method} get-intracondition-tests% (CONDITION @t{simple-pattern})
@anchor{go to the get-intracondition-tests% simple-pattern method}@c
@methodsubindex{get-intracondition-tests%}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} get-join-tests-from-condition CONDITION PREV-CONDS
@anchor{go to the get-join-tests-from-condition generic function}@c
@genericsubindex{get-join-tests-from-condition}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} get-join-tests-from-condition (CONDITION @t{pattern}) (PREV-CONDS @t{list})
@anchor{go to the get-join-tests-from-condition pattern list method}@c
@methodsubindex{get-join-tests-from-condition}@c
@table @strong
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} get-network NODE &optional TEMPLATE-NAME
@anchor{go to the get-network generic function}@c
@genericsubindex{get-network}@c
@deffnx {Generic Function} (setf@ get-network) VALUE NODE &optional TEMPLATE-NAME
@anchor{go to the (setf get-network) generic function}@c
@genericsubindex{(setf get-network)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} get-network (NODE @t{alpha-top-node}) &optional TEMPLATE-NAME
@anchor{go to the get-network alpha-top-node method}@c
@methodsubindex{get-network}@c
@deffnx {Method} (setf@ get-network) VALUE (NODE @t{alpha-top-node}) &optional TEMPLATE-NAME

@anchor{go to the (setf get-network) t alpha-top-node method}@c
@methodsubindex{(setf get-network)}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} get/initialize-network NODE &optional TEMPLATE-NAME
@anchor{go to the get/initialize-network generic function}@c
@genericsubindex{get/initialize-network}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} get/initialize-network (NODE @t{alpha-top-node}) &optional TEMPLATE-NAME
@anchor{go to the get/initialize-network alpha-top-node method}@c
@methodsubindex{get/initialize-network}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} inactivate NODE OBJECT
@anchor{go to the inactivate generic function}@c
@genericsubindex{inactivate}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item Methods
@deffn {Method} inactivate (NODE @t{beta-negative-node}) (WME @t{fact})
@anchor{go to the inactivate beta-negative-node fact method}@c
@methodsubindex{inactivate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} inactivate (NODE @t{beta-memory-node}) (TOKEN @t{token}) @t{before}
@anchor{go to the inactivate beta-memory-node token before method}@c
@methodsubindex{inactivate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} inactivate (NODE @t{beta-memory-node}) (FACT @t{fact}) @t{before}
@anchor{go to the inactivate beta-memory-node fact before method}@c
@methodsubindex{inactivate}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} inactivate (NODE @t{alpha-memory-node}) (WME @t{fact})
@anchor{go to the inactivate alpha-memory-node fact method}@c
@methodsubindex{inactivate}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} inactivate (NODE @t{alpha-top-node}) (WME @t{fact})
@anchor{go to the inactivate alpha-top-node fact method}@c
@methodsubindex{inactivate}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} inactivate (NODE @t{alpha-test-node}) (WME @t{fact}) @t{after}
@anchor{go to the inactivate alpha-test-node fact after method}@c
@methodsubindex{inactivate}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} inactivate (NODE @t{node}) OBJECT
@anchor{go to the inactivate node t method}@c
@methodsubindex{inactivate}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} inactivate-children NODE OBJECT
@anchor{go to the inactivate-children generic function}@c
@genericsubindex{inactivate-children}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} inactivate-children (NODE @t{node}) OBJECT
@anchor{go to the inactivate-children node t method}@c
@methodsubindex{inactivate-children}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} includes-p FACT TOKEN
@anchor{go to the includes-p generic function}@c
@genericsubindex{includes-p}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} includes-p (INCLUDED-TOKEN @t{token}) (TOKEN @t{token})
@anchor{go to the includes-p token token method}@c
@methodsubindex{includes-p}@c
@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@deffn {Method} includes-p (FACT @t{fact}) (TOKEN @t{token})
@anchor{go to the includes-p fact token method}@c
@methodsubindex{includes-p}@c
@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} initialize-network NODE &optional TEMPLATE-NAME
@anchor{go to the initialize-network generic function}@c
@genericsubindex{initialize-network}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} initialize-network (NODE @t{alpha-top-node}) &optional TEMPLATE-NAME
@anchor{go to the initialize-network alpha-top-node method}@c
@methodsubindex{initialize-network}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} is-watcher WATCHER
@anchor{go to the is-watcher generic function}@c
@genericsubindex{is-watcher}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} is-watcher (WATCHER @t{symbol})
@anchor{go to the is-watcher symbol method}@c
@methodsubindex{is-watcher}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} items OBJECT
@anchor{go to the items generic function}@c
@genericsubindex{items}@c
@deffnx {Generic Function} (setf@ items) NEW-VALUE OBJECT
@anchor{go to the (setf items) generic function}@c
@genericsubindex{(setf items)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} items (MEMORY-NODE @t{memory-node})
@anchor{go to the items memory-node method}@c
@methodsubindex{items}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ items) NEW-VALUE (MEMORY-NODE @t{memory-node})
@anchor{go to the (setf items) t memory-node method}@c
@methodsubindex{(setf items)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} match-equal-p MATCH1 MATCH2
@anchor{go to the match-equal-p generic function}@c
@genericsubindex{match-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} match-equal-p (MATCH1 @t{match}) (MATCH2 @t{match})
@anchor{go to the match-equal-p match match method}@c
@methodsubindex{match-equal-p}@c
@table @strong
@item Source
@ref{go to the matches.lisp file, , @t{matches}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} match-rule OBJECT
@anchor{go to the match-rule generic function}@c
@genericsubindex{match-rule}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} match-rule (MATCH @t{match})
@anchor{go to the match-rule match method}@c
@methodsubindex{match-rule}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the matches.lisp file, , @t{matches}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} match-token OBJECT
@anchor{go to the match-token generic function}@c
@genericsubindex{match-token}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} match-token (MATCH @t{match})
@anchor{go to the match-token match method}@c
@methodsubindex{match-token}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the matches.lisp file, , @t{matches}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} memory OBJECT
@anchor{go to the memory generic function}@c
@genericsubindex{memory}@c
@deffnx {Generic Function} (setf@ memory) NEW-VALUE OBJECT
@anchor{go to the (setf memory) generic function}@c
@genericsubindex{(setf memory)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} memory (ALPHA-TEST-NODE @t{alpha-test-node})
@anchor{go to the memory alpha-test-node method}@c
@methodsubindex{memory}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ memory) NEW-VALUE (ALPHA-TEST-NODE @t{alpha-test-node})
@anchor{go to the (setf memory) t alpha-test-node method}@c
@methodsubindex{(setf memory)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} modify% FACT-SPEC MOD-LIST
@anchor{go to the modify% generic function}@c
@genericsubindex{modify%}@c
@table @strong
@item Package
@ref{go to the exil package, , @t{exil}}
@item Methods
@deffn {Method} modify% (FACT-SPEC @t{integer}) MOD-LIST
@anchor{go to the modify% integer t method}@c
@methodsubindex{modify%}@c
@table @strong
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end deffn
@deffn {Method} modify% (FACT-SPEC @t{list}) MOD-LIST
@anchor{go to the modify% list t method}@c
@methodsubindex{modify%}@c
@table @strong
@item Source
@ref{go to the export.lisp file, , @t{export}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} negative-wmes OBJECT
@anchor{go to the negative-wmes generic function}@c
@genericsubindex{negative-wmes}@c
@deffnx {Generic Function} (setf@ negative-wmes) NEW-VALUE OBJECT
@anchor{go to the (setf negative-wmes) generic function}@c
@genericsubindex{(setf negative-wmes)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} negative-wmes (TOKEN @t{token})
@anchor{go to the negative-wmes token method}@c
@methodsubindex{negative-wmes}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ negative-wmes) NEW-VALUE (TOKEN @t{token})
@anchor{go to the (setf negative-wmes) t token method}@c
@methodsubindex{(setf negative-wmes)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} networks OBJECT
@anchor{go to the networks generic function}@c
@genericsubindex{networks}@c
@deffnx {Generic Function} (setf@ networks) NEW-VALUE OBJECT
@anchor{go to the (setf networks) generic function}@c
@genericsubindex{(setf networks)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} networks (ALPHA-TOP-NODE @t{alpha-top-node})
@anchor{go to the networks alpha-top-node method}@c
@methodsubindex{networks}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ networks) NEW-VALUE (ALPHA-TOP-NODE @t{alpha-top-node})
@anchor{go to the (setf networks) t alpha-top-node method}@c
@methodsubindex{(setf networks)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} newer-than MATCH1 MATCH2
@anchor{go to the newer-than generic function}@c
@genericsubindex{newer-than}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} newer-than (MATCH1 @t{match}) (MATCH2 @t{match})
@anchor{go to the newer-than match match method}@c
@methodsubindex{newer-than}@c
@table @strong
@item Source
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} node-equal-p NODE1 NODE2
@anchor{go to the node-equal-p generic function}@c
@genericsubindex{node-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item Methods
@deffn {Method} node-equal-p (NODE1 @t{beta-join-node}) (NODE2 @t{beta-join-node})
@anchor{go to the node-equal-p beta-join-node beta-join-node method}@c
@methodsubindex{node-equal-p}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} node-equal-p (NODE1 @t{alpha-test-node}) (NODE2 @t{alpha-test-node})
@anchor{go to the node-equal-p alpha-test-node alpha-test-node method}@c
@methodsubindex{node-equal-p}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} node-equal-p (NODE1 @t{(eql nil)}) (NODE2 @t{(eql nil)})
@anchor{go to the node-equal-p (eql nil) (eql nil) method}@c
@methodsubindex{node-equal-p}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@deffn {Method} node-equal-p (NODE1 @t{node}) (NODE2 @t{node})
@anchor{go to the node-equal-p node node method}@c
@methodsubindex{node-equal-p}@c
@table @strong
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} parent OBJECT
@anchor{go to the parent generic function}@c
@genericsubindex{parent}@c
@deffnx {Generic Function} (setf@ parent) NEW-VALUE OBJECT
@anchor{go to the (setf parent) generic function}@c
@genericsubindex{(setf parent)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} parent (BETA-NODE @t{beta-node})
@anchor{go to the parent beta-node method}@c
@methodsubindex{parent}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ parent) NEW-VALUE (BETA-NODE @t{beta-node})
@anchor{go to the (setf parent) t beta-node method}@c
@methodsubindex{(setf parent)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} parent (TOKEN @t{token})
@anchor{go to the parent token method}@c
@methodsubindex{parent}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} perform-join-test TEST TOKEN WME
@anchor{go to the perform-join-test generic function}@c
@genericsubindex{perform-join-test}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} perform-join-test (TEST @t{test}) (TOKEN @t{token}) (WME @t{fact})
@anchor{go to the perform-join-test test token fact method}@c
@methodsubindex{perform-join-test}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} perform-join-tests TESTS TOKEN WME
@anchor{go to the perform-join-tests generic function}@c
@genericsubindex{perform-join-tests}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} perform-join-tests (TESTS @t{list}) (TOKEN @t{token}) (WME @t{fact})
@anchor{go to the perform-join-tests list token fact method}@c
@methodsubindex{perform-join-tests}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} previous-condition OBJECT
@anchor{go to the previous-condition generic function}@c
@genericsubindex{previous-condition}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} previous-condition (TEST @t{test})
@anchor{go to the previous-condition test method}@c
@methodsubindex{previous-condition}@c
tells, how many conditions back i must go@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} previous-field OBJECT
@anchor{go to the previous-field generic function}@c
@genericsubindex{previous-field}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} previous-field (TEST @t{test})
@anchor{go to the previous-field test method}@c
@methodsubindex{previous-field}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} previous-wme TOKEN &optional N
@anchor{go to the previous-wme generic function}@c
@genericsubindex{previous-wme}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} previous-wme (TOKEN @t{token}) &optional N
@anchor{go to the previous-wme token method}@c
@methodsubindex{previous-wme}@c
gives wme from token n wmes back@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} productions OBJECT
@anchor{go to the productions generic function}@c
@genericsubindex{productions}@c
@deffnx {Generic Function} (setf@ productions) NEW-VALUE OBJECT
@anchor{go to the (setf productions) generic function}@c
@genericsubindex{(setf productions)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} productions (BETA-MEMORY-NODE @t{beta-memory-node})
@anchor{go to the productions beta-memory-node method}@c
@methodsubindex{productions}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ productions) NEW-VALUE (BETA-MEMORY-NODE @t{beta-memory-node})
@anchor{go to the (setf productions) t beta-memory-node method}@c
@methodsubindex{(setf productions)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} remove-matches RULE
@anchor{go to the remove-matches generic function}@c
@genericsubindex{remove-matches}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} remove-matches RULE
@anchor{go to the remove-matches t method}@c
@methodsubindex{remove-matches}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} simple-fact-key-name OBJECT
@anchor{go to the simple-fact-key-name generic function}@c
@genericsubindex{simple-fact-key-name}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} simple-fact-key-name (ALPHA-TOP-NODE @t{alpha-top-node})
@anchor{go to the simple-fact-key-name alpha-top-node method}@c
@methodsubindex{simple-fact-key-name}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} simpler-than RULE1 RULE2
@anchor{go to the simpler-than generic function}@c
@genericsubindex{simpler-than}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} simpler-than (MATCH1 @t{match}) (MATCH2 @t{match})
@anchor{go to the simpler-than match match method}@c
@methodsubindex{simpler-than}@c
@table @strong
@item Source
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@end table
@end deffn
@deffn {Method} simpler-than (RULE1 @t{rule}) (RULE2 @t{rule})
@anchor{go to the simpler-than rule rule method}@c
@methodsubindex{simpler-than}@c
@table @strong
@item Source
@ref{go to the strategies.lisp file, , @t{strategies}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} strategies 
@anchor{go to the strategies generic function}@c
@genericsubindex{strategies}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} strategies 
@anchor{go to the strategies method}@c
@methodsubindex{strategies}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} test NODE WME
@anchor{go to the test generic function}@c
@genericsubindex{test}@c
provides testing part of alpha-test-node activation@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Methods
@deffn {Method} test (NODE @t{template-fact-test-node}) (WME @t{template-fact})
@anchor{go to the test template-fact-test-node template-fact method}@c
@methodsubindex{test}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} test (NODE @t{simple-fact-test-node}) (WME @t{simple-fact})
@anchor{go to the test simple-fact-test-node simple-fact method}@c
@methodsubindex{test}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} test (NODE @t{alpha-test-node}) (WME @t{fact})
@anchor{go to the test alpha-test-node fact method}@c
@methodsubindex{test}@c
@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} test-equal-p TEST1 TEST2
@anchor{go to the test-equal-p generic function}@c
@genericsubindex{test-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} test-equal-p (TEST1 @t{test}) (TEST2 @t{test})
@anchor{go to the test-equal-p test test method}@c
@methodsubindex{test-equal-p}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tested-field OBJECT
@anchor{go to the tested-field generic function}@c
@genericsubindex{tested-field}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} tested-field (ALPHA-TEST-NODE @t{alpha-test-node})
@anchor{go to the tested-field alpha-test-node method}@c
@methodsubindex{tested-field}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tests OBJECT
@anchor{go to the tests generic function}@c
@genericsubindex{tests}@c
@deffnx {Generic Function} (setf@ tests) NEW-VALUE OBJECT
@anchor{go to the (setf tests) generic function}@c
@genericsubindex{(setf tests)}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} tests (BETA-JOIN-NODE @t{beta-join-node})
@anchor{go to the tests beta-join-node method}@c
@methodsubindex{tests}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@deffn {Method} (setf@ tests) NEW-VALUE (BETA-JOIN-NODE @t{beta-join-node})
@anchor{go to the (setf tests) t beta-join-node method}@c
@methodsubindex{(setf tests)}@c
automatically generated writer method@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tests-equal-p TEST-LIST1 TEST-LIST2
@anchor{go to the tests-equal-p generic function}@c
@genericsubindex{tests-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} tests-equal-p (TEST-LIST1 @t{list}) (TEST-LIST2 @t{list})
@anchor{go to the tests-equal-p list list method}@c
@methodsubindex{tests-equal-p}@c
@table @strong
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} timestamp OBJECT
@anchor{go to the timestamp generic function}@c
@genericsubindex{timestamp}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} timestamp (MATCH @t{match})
@anchor{go to the timestamp match method}@c
@methodsubindex{timestamp}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the matches.lisp file, , @t{matches}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tmpl-object-equal-p OBJECT1 OBJECT2
@anchor{go to the tmpl-object-equal-p generic function}@c
@genericsubindex{tmpl-object-equal-p}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} tmpl-object-equal-p (OBJECT1 @t{template-object}) (OBJECT2 @t{template-object})
@anchor{go to the tmpl-object-equal-p template-object template-object method}@c
@methodsubindex{tmpl-object-equal-p}@c
template-object equality predicate@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tmpl-object-slot-value OBJECT SLOT-NAME
@anchor{go to the tmpl-object-slot-value generic function}@c
@genericsubindex{tmpl-object-slot-value}@c
@deffnx {Generic Function} (setf@ tmpl-object-slot-value) VAL OBJECT SLOT-NAME
@anchor{go to the (setf tmpl-object-slot-value) generic function}@c
@genericsubindex{(setf tmpl-object-slot-value)}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} tmpl-object-slot-value (OBJECT @t{template-object}) SLOT-NAME
@anchor{go to the tmpl-object-slot-value template-object t method}@c
@methodsubindex{tmpl-object-slot-value}@c
@deffnx {Method} (setf@ tmpl-object-slot-value) VAL (OBJECT @t{template-object}) SLOT-NAME

@anchor{go to the (setf tmpl-object-slot-value) t template-object t method}@c
@methodsubindex{(setf tmpl-object-slot-value)}@c
get the template-object slot value according to the slot name@table @strong
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} tmpl-pattern-slot-value PATTERN SLOT-NAME
@anchor{go to the tmpl-pattern-slot-value generic function}@c
@genericsubindex{tmpl-pattern-slot-value}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Methods
@deffn {Method} tmpl-pattern-slot-value (PATTERN @t{template-pattern}) SLOT-NAME
@anchor{go to the tmpl-pattern-slot-value template-pattern t method}@c
@methodsubindex{tmpl-pattern-slot-value}@c
@table @strong
@item Source
@ref{go to the patterns.lisp file, , @t{patterns}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} token WME &optional PARENT
@anchor{go to the token generic function}@c
@genericsubindex{token}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} token WME &optional PARENT
@anchor{go to the token t method}@c
@methodsubindex{token}@c
@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} value OBJECT
@anchor{go to the value generic function}@c
@genericsubindex{value}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} value (ALPHA-TEST-NODE @t{alpha-test-node})
@anchor{go to the value alpha-test-node method}@c
@methodsubindex{value}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} variable-bindings PATTERN FACT
@anchor{go to the variable-bindings generic function}@c
@genericsubindex{variable-bindings}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} variable-bindings (PATTERN @t{template-pattern}) (FACT @t{template-fact})
@anchor{go to the variable-bindings template-pattern template-fact method}@c
@methodsubindex{variable-bindings}@c
@table @strong
@item Source
@ref{go to the activations.lisp file, , @t{activations}} (Lisp file)
@end table
@end deffn
@deffn {Method} variable-bindings (PATTERN @t{simple-pattern}) (FACT @t{simple-fact})
@anchor{go to the variable-bindings simple-pattern simple-fact method}@c
@methodsubindex{variable-bindings}@c
@table @strong
@item Source
@ref{go to the activations.lisp file, , @t{activations}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} watchers 
@anchor{go to the watchers generic function}@c
@genericsubindex{watchers}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Methods
@deffn {Method} watchers 
@anchor{go to the watchers method}@c
@methodsubindex{watchers}@c
@table @strong
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} wme OBJECT
@anchor{go to the wme generic function}@c
@genericsubindex{wme}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Methods
@deffn {Method} wme (TOKEN @t{token})
@anchor{go to the wme token method}@c
@methodsubindex{wme}@c
automatically generated reader method@table @strong
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@end table
@end deffn
@end table
@end deffn

@node Internal classes, , Internal generic functions, Internal definitions
@subsection Classes

@deftp {Class} alpha-memory-node
@anchor{go to the alpha-memory-node class}@c
@classsubindex{alpha-memory-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the memory-node class, , @t{memory-node}} (class)
@item
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the find/create-neg-node beta-memory-node list alpha-memory-node method, , @t{find/create-neg-node}} (method)
@item
@ref{go to the find/create-join-node beta-memory-node list alpha-memory-node method, , @t{find/create-join-node}} (method)
@item
@ref{go to the inactivate alpha-memory-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the activate alpha-memory-node fact method, , @t{activate}} (method)
@end itemize
@end table
@end deftp
@deftp {Class} alpha-node
@anchor{go to the alpha-node class}@c
@classsubindex{alpha-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@ref{go to the node class, , @t{node}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the alpha-test-node class, , @t{alpha-test-node}} (class)
@item
@ref{go to the simple-fact-alpha-node class, , @t{simple-fact-alpha-node}} (class)
@item
@ref{go to the template-fact-alpha-node class, , @t{template-fact-alpha-node}} (class)
@item
@ref{go to the alpha-subtop-node class, , @t{alpha-subtop-node}} (class)
@item
@ref{go to the alpha-top-node class, , @t{alpha-top-node}} (class)
@item
@ref{go to the alpha-memory-node class, , @t{alpha-memory-node}} (class)
@end itemize
@item Direct methods
@ref{go to the find-test-node alpha-node t t method, , @t{find-test-node}} (method)
@end table
@end deftp
@deftp {Class} alpha-subtop-node
@anchor{go to the alpha-subtop-node class}@c
@classsubindex{alpha-subtop-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the simple-fact-subtop-node class, , @t{simple-fact-subtop-node}} (class)
@item
@ref{go to the template-fact-subtop-node class, , @t{template-fact-subtop-node}} (class)
@end itemize
@item Direct methods
@ref{go to the activate alpha-subtop-node fact method, , @t{activate}} (method)
@end table
@end deftp
@deftp {Class} alpha-test-node
@anchor{go to the alpha-test-node class}@c
@classsubindex{alpha-test-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the simple-fact-test-node class, , @t{simple-fact-test-node}} (class)
@item
@ref{go to the template-fact-test-node class, , @t{template-fact-test-node}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the inactivate alpha-test-node fact after method, , @t{inactivate}} (method)
@item
@ref{go to the activate alpha-test-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate-memory alpha-test-node fact method, , @t{activate-memory}} (method)
@item
@ref{go to the activate-children alpha-test-node fact method, , @t{activate-children}} (method)
@item
@ref{go to the test alpha-test-node fact method, , @t{test}} (method)
@item
@t{print-object}
@item
@ref{go to the node-equal-p alpha-test-node alpha-test-node method, , @t{node-equal-p}} (method)
@item
@t{memory}
@item
@ref{go to the memory alpha-test-node method, , @t{memory}} (method)
@item
@ref{go to the value alpha-test-node method, , @t{value}} (method)
@item
@ref{go to the tested-field alpha-test-node method, , @t{tested-field}} (method)
@end itemize
@item Direct slots
@defvr {Slot} tested-field
@slotsubindex{tested-field}@c
@table @strong
@item Initargs
@t{:tested-field}
@item Initform
@t{(error "tested-field slot has to be specified")}
@item Readers
@ref{go to the tested-field generic function, , @t{tested-field}} (generic function)
@end table
@end defvr
@defvr {Slot} desired-value
@slotsubindex{desired-value}@c
@table @strong
@item Initargs
@t{:value}
@item Initform
@t{(error "desired-value slot has to be specified")}
@item Readers
@ref{go to the value generic function, , @t{value}} (generic function)
@end table
@end defvr
@defvr {Slot} alpha-memory
@slotsubindex{alpha-memory}@c
@table @strong
@item Initargs
@t{:memory}
@item Readers
@ref{go to the memory generic function, , @t{memory}} (generic function)
@item Writers
@ref{go to the (setf memory) generic function, , @t{(setf memory)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} alpha-top-node
@anchor{go to the alpha-top-node class}@c
@classsubindex{alpha-top-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item Direct methods
@itemize @bullet
@item
@ref{go to the inactivate alpha-top-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the activate alpha-top-node fact method, , @t{activate}} (method)
@item
@t{initialize-instance}
@item
@ref{go to the get/initialize-network alpha-top-node method, , @t{get/initialize-network}} (method)
@item
@ref{go to the initialize-network alpha-top-node method, , @t{initialize-network}} (method)
@item
@t{get-network}
@item
@ref{go to the get-network alpha-top-node method, , @t{get-network}} (method)
@item
@ref{go to the simple-fact-key-name alpha-top-node method, , @t{simple-fact-key-name}} (method)
@item
@t{networks}
@item
@ref{go to the networks alpha-top-node method, , @t{networks}} (method)
@end itemize
@item Direct slots
@defvr {Slot} dataflow-networks
@slotsubindex{dataflow-networks}@c
@table @strong
@item Initform
@t{(make-hash-table)}
@item Readers
@ref{go to the networks generic function, , @t{networks}} (generic function)
@item Writers
@ref{go to the (setf networks) generic function, , @t{(setf networks)}} (generic function)
@end table
@end defvr
@defvr {Slot} simple-fact-key-name
@slotsubindex{simple-fact-key-name}@c
@table @strong
@item Initform
@t{(gensym "simple-fact")}
@item Readers
@ref{go to the simple-fact-key-name generic function, , @t{simple-fact-key-name}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} beta-join-node
@anchor{go to the beta-join-node class}@c
@classsubindex{beta-join-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@item Direct superclasses
@ref{go to the beta-node class, , @t{beta-node}} (class)
@item Direct subclasses
@ref{go to the beta-negative-node class, , @t{beta-negative-node}} (class)
@item Direct methods
@itemize @bullet
@item
@ref{go to the node-equal-p beta-join-node beta-join-node method, , @t{node-equal-p}} (method)
@item
@ref{go to the activate beta-join-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate beta-join-node token method, , @t{activate}} (method)
@item
@ref{go to the beta-memory beta-join-node method, , @t{beta-memory}} (method)
@item
@t{initialize-instance}
@item
@t{tests}
@item
@ref{go to the tests beta-join-node method, , @t{tests}} (method)
@item
@ref{go to the alpha-memory beta-join-node method, , @t{alpha-memory}} (method)
@end itemize
@item Direct slots
@defvr {Slot} alpha-memory
@slotsubindex{alpha-memory}@c
@table @strong
@item Initargs
@t{:alpha-memory}
@item Initform
@t{(error "alpha-memory slot has to be specified")}
@item Readers
@ref{go to the alpha-memory generic function, , @t{alpha-memory}} (generic function)
@end table
@end defvr
@defvr {Slot} tests
@slotsubindex{tests}@c
@table @strong
@item Initargs
@t{:tests}
@item Readers
@ref{go to the tests generic function, , @t{tests}} (generic function)
@item Writers
@ref{go to the (setf tests) generic function, , @t{(setf tests)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} beta-memory-node
@anchor{go to the beta-memory-node class}@c
@classsubindex{beta-memory-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the memory-node class, , @t{memory-node}} (class)
@item
@ref{go to the beta-node class, , @t{beta-node}} (class)
@end itemize
@item Direct subclasses
@ref{go to the beta-top-node class, , @t{beta-top-node}} (class)
@item Direct methods
@itemize @bullet
@item
@ref{go to the find/create-neg-node beta-memory-node list alpha-memory-node method, , @t{find/create-neg-node}} (method)
@item
@ref{go to the find/create-join-node beta-memory-node list alpha-memory-node method, , @t{find/create-join-node}} (method)
@item
@t{print-object}
@item
@ref{go to the delete-production beta-memory-node rule method, , @t{delete-production}} (method)
@item
@ref{go to the add-production beta-memory-node rule method, , @t{add-production}} (method)
@item
@ref{go to the inactivate beta-memory-node token before method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate beta-memory-node fact before method, , @t{inactivate}} (method)
@item
@ref{go to the broken-match beta-memory-node token method, , @t{broken-match}} (method)
@item
@ref{go to the activate beta-memory-node token method, , @t{activate}} (method)
@item
@ref{go to the complete-match beta-memory-node token method, , @t{complete-match}} (method)
@item
@t{productions}
@item
@ref{go to the productions beta-memory-node method, , @t{productions}} (method)
@end itemize
@item Direct slots
@defvr {Slot} productions
@slotsubindex{productions}@c
@table @strong
@item Readers
@ref{go to the productions generic function, , @t{productions}} (generic function)
@item Writers
@ref{go to the (setf productions) generic function, , @t{(setf productions)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} beta-negative-node
@anchor{go to the beta-negative-node class}@c
@classsubindex{beta-negative-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the memory-node class, , @t{memory-node}} (class)
@item
@ref{go to the beta-join-node class, , @t{beta-join-node}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the inactivate beta-negative-node fact method, , @t{inactivate}} (method)
@item
@ref{go to the activate beta-negative-node fact method, , @t{activate}} (method)
@item
@ref{go to the activate beta-negative-node token method, , @t{activate}} (method)
@item
@ref{go to the get-bad-wmes beta-negative-node token method, , @t{get-bad-wmes}} (method)
@end itemize
@end table
@end deftp
@deftp {Class} beta-node
@anchor{go to the beta-node class}@c
@classsubindex{beta-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@item Direct superclasses
@ref{go to the node class, , @t{node}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the beta-memory-node class, , @t{beta-memory-node}} (class)
@item
@ref{go to the beta-join-node class, , @t{beta-join-node}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@t{parent}
@item
@ref{go to the parent beta-node method, , @t{parent}} (method)
@end itemize
@item Direct slots
@defvr {Slot} parent
@slotsubindex{parent}@c
@table @strong
@item Initargs
@t{:parent}
@item Readers
@ref{go to the parent generic function, , @t{parent}} (generic function)
@item Writers
@ref{go to the (setf parent) generic function, , @t{(setf parent)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} beta-top-node
@anchor{go to the beta-top-node class}@c
@classsubindex{beta-top-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@item Direct superclasses
@ref{go to the beta-memory-node class, , @t{beta-memory-node}} (class)
@item Direct slots
@defvr {Slot} items
@slotsubindex{items}@c
@table @strong
@item Initform
@t{(list (make-instance 'exil-rete::empty-token))}
@end table
@end defvr
@end table
@end deftp
@deftp {Class} described-object
@anchor{go to the described-object class}@c
@classsubindex{described-object}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct subclasses
@ref{go to the node class, , @t{node}} (class)
@item Direct methods
@itemize @bullet
@item
@t{print-object}
@item
@t{description}
@item
@ref{go to the description described-object method, , @t{description}} (method)
@end itemize
@item Direct slots
@defvr {Slot} description
@slotsubindex{description}@c
@table @strong
@item Initargs
@t{:description}
@item Initform
@t{""}
@item Readers
@ref{go to the description generic function, , @t{description}} (generic function)
@item Writers
@ref{go to the (setf description) generic function, , @t{(setf description)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} empty-token
@anchor{go to the empty-token class}@c
@classsubindex{empty-token}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@item Direct superclasses
@ref{go to the token class, , @t{token}} (class)
@item Direct methods
@ref{go to the token-equal-p empty-token empty-token method, , @t{token-equal-p}} (method)
@item Direct slots
@defvr {Slot} wme
@slotsubindex{wme}@c
@table @strong
@end table
@end defvr
@end table
@end deftp
@deftp {Class} exil-environment
@anchor{go to the exil-environment class}@c
@classsubindex{exil-environment}@c
keeps track of defined fact-groups, templates, rules, strategies and watchers and stores the asserted facts and the agenda@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the environment.lisp file, , @t{environment}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct slots
@defvr {Slot} facts
@slotsubindex{facts}@c
list of fact instances@table @strong
@end table
@end defvr
@defvr {Slot} fact-groups
@slotsubindex{fact-groups}@c
((group-name fact-description*)*)@table @strong
@end table
@end defvr
@defvr {Slot} templates
@slotsubindex{templates}@c
hash table, assigns template instance to name@table @strong
@item Initform
@t{(make-hash-table :test 'equalp)}
@end table
@end defvr
@defvr {Slot} rules
@slotsubindex{rules}@c
hash table, assigns rule instance to name@table @strong
@item Initform
@t{(make-hash-table :test 'equalp)}
@end table
@end defvr
@defvr {Slot} rete
@slotsubindex{rete}@c
the rete singleton instance@table @strong
@item Initform
@t{(exil-rete:make-rete)}
@end table
@end defvr
@defvr {Slot} agenda
@slotsubindex{agenda}@c
list of matches@table @strong
@end table
@end defvr
@defvr {Slot} strategies
@slotsubindex{strategies}@c
alist, assigns strategy function to name symbol@table @strong
@item Initform
@t{`((exil-env::default ,@@#'exil-env::depth-strategy)
  (exil-env::depth-strategy ,@@#'exil-env::depth-strategy)
  (exil-env::breadth-strategy ,@@#'exil-env::breadth-strategy)
  (exil-env::simplicity-strategy ,@@#'exil-env::simplicity-strategy)
  (exil-env::complexity-strategy ,@@#'exil-env::complexity-strategy))}
@end table
@end defvr
@defvr {Slot} current-strategy-name
@slotsubindex{current-strategy-name}@c
symbol@table @strong
@item Initform
@t{'exil-env::default}
@end table
@end defvr
@defvr {Slot} watchers
@slotsubindex{watchers}@c
alist, (:facts, :rules, :activations) -> t/nil@table @strong
@item Initform
@t{'((:facts) (:rules) (:activations))}
@end table
@end defvr
@end table
@end deftp
@deftp {Class} match
@anchor{go to the match class}@c
@classsubindex{match}@c
@table @strong
@item Package
@ref{go to the exil-env package, , @t{exil-env}}
@item Source
@ref{go to the matches.lisp file, , @t{matches}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct methods
@itemize @bullet
@item
@ref{go to the simpler-than match match method, , @t{simpler-than}} (method)
@item
@ref{go to the newer-than match match method, , @t{newer-than}} (method)
@item
@ref{go to the activate-rule match method, , @t{activate-rule}} (method)
@item
@t{print-object}
@item
@ref{go to the match-equal-p match match method, , @t{match-equal-p}} (method)
@item
@ref{go to the timestamp match method, , @t{timestamp}} (method)
@item
@ref{go to the match-token match method, , @t{match-token}} (method)
@item
@ref{go to the match-rule match method, , @t{match-rule}} (method)
@end itemize
@item Direct slots
@defvr {Slot} rule
@slotsubindex{rule}@c
@table @strong
@item Initargs
@t{:rule}
@item Initform
@t{(error "match rule has to be specified")}
@item Readers
@ref{go to the match-rule generic function, , @t{match-rule}} (generic function)
@end table
@end defvr
@defvr {Slot} token
@slotsubindex{token}@c
@table @strong
@item Initargs
@t{:token}
@item Initform
@t{(error "match token has to be specified")}
@item Readers
@ref{go to the match-token generic function, , @t{match-token}} (generic function)
@end table
@end defvr
@defvr {Slot} timestamp
@slotsubindex{timestamp}@c
@table @strong
@item Initargs
@t{:timestamp}
@item Initform
@t{(get-internal-real-time)}
@item Readers
@ref{go to the timestamp generic function, , @t{timestamp}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} memory-node
@anchor{go to the memory-node class}@c
@classsubindex{memory-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item Direct superclasses
@ref{go to the node class, , @t{node}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the alpha-memory-node class, , @t{alpha-memory-node}} (class)
@item
@ref{go to the beta-memory-node class, , @t{beta-memory-node}} (class)
@item
@ref{go to the beta-negative-node class, , @t{beta-negative-node}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the add-item memory-node t method, , @t{add-item}} (method)
@item
@t{items}
@item
@ref{go to the items memory-node method, , @t{items}} (method)
@end itemize
@item Direct slots
@defvr {Slot} items
@slotsubindex{items}@c
@table @strong
@item Readers
@ref{go to the items generic function, , @t{items}} (generic function)
@item Writers
@ref{go to the (setf items) generic function, , @t{(setf items)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} node
@anchor{go to the node class}@c
@classsubindex{node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-generic-node.lisp file, , @t{rete-generic-node}} (Lisp file)
@item Direct superclasses
@ref{go to the described-object class, , @t{described-object}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the memory-node class, , @t{memory-node}} (class)
@item
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item
@ref{go to the beta-node class, , @t{beta-node}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the inactivate node t method, , @t{inactivate}} (method)
@item
@ref{go to the inactivate-children node t method, , @t{inactivate-children}} (method)
@item
@ref{go to the activate-children node t method, , @t{activate-children}} (method)
@item
@ref{go to the add-children node list method, , @t{add-children}} (method)
@item
@ref{go to the add-child node node method, , @t{add-child}} (method)
@item
@ref{go to the node-equal-p node node method, , @t{node-equal-p}} (method)
@item
@t{children}
@item
@ref{go to the children node method, , @t{children}} (method)
@end itemize
@item Direct slots
@defvr {Slot} children
@slotsubindex{children}@c
@table @strong
@item Readers
@ref{go to the children generic function, , @t{children}} (generic function)
@item Writers
@ref{go to the (setf children) generic function, , @t{(setf children)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} rete
@anchor{go to the rete class}@c
@classsubindex{rete}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-net-creation.lisp file, , @t{rete-net-creation}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct methods
@itemize @bullet
@item
@t{beta-top-node}
@item
@ref{go to the beta-top-node rete method, , @t{beta-top-node}} (method)
@item
@ref{go to the alpha-top-node rete method, , @t{alpha-top-node}} (method)
@end itemize
@item Direct slots
@defvr {Slot} alpha-top-node
@slotsubindex{alpha-top-node}@c
@table @strong
@item Initform
@t{(make-instance 'exil-rete::alpha-top-node)}
@item Readers
@ref{go to the alpha-top-node generic function, , @t{alpha-top-node}} (generic function)
@end table
@end defvr
@defvr {Slot} beta-top-node
@slotsubindex{beta-top-node}@c
@table @strong
@item Initform
@t{(make-instance 'exil-rete::beta-top-node)}
@item Readers
@ref{go to the beta-top-node generic function, , @t{beta-top-node}} (generic function)
@item Writers
@ref{go to the (setf beta-top-node) generic function, , @t{(setf beta-top-node)}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} simple-fact-alpha-node
@anchor{go to the simple-fact-alpha-node class}@c
@classsubindex{simple-fact-alpha-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the simple-fact-test-node class, , @t{simple-fact-test-node}} (class)
@item
@ref{go to the simple-fact-subtop-node class, , @t{simple-fact-subtop-node}} (class)
@end itemize
@item Direct methods
@ref{go to the find/create-test-node simple-fact-alpha-node t t method, , @t{find/create-test-node}} (method)
@end table
@end deftp
@deftp {Class} simple-fact-subtop-node
@anchor{go to the simple-fact-subtop-node class}@c
@classsubindex{simple-fact-subtop-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the simple-fact-alpha-node class, , @t{simple-fact-alpha-node}} (class)
@item
@ref{go to the alpha-subtop-node class, , @t{alpha-subtop-node}} (class)
@end itemize
@item Direct methods
@ref{go to the create-alpha-net% simple-pattern simple-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@end table
@end deftp
@deftp {Class} simple-fact-test-node
@anchor{go to the simple-fact-test-node class}@c
@classsubindex{simple-fact-test-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the simple-fact-alpha-node class, , @t{simple-fact-alpha-node}} (class)
@item
@ref{go to the alpha-test-node class, , @t{alpha-test-node}} (class)
@end itemize
@item Direct methods
@ref{go to the test simple-fact-test-node simple-fact method, , @t{test}} (method)
@end table
@end deftp
@deftp {Class} template-fact-alpha-node
@anchor{go to the template-fact-alpha-node class}@c
@classsubindex{template-fact-alpha-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@ref{go to the alpha-node class, , @t{alpha-node}} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the template-fact-test-node class, , @t{template-fact-test-node}} (class)
@item
@ref{go to the template-fact-subtop-node class, , @t{template-fact-subtop-node}} (class)
@end itemize
@item Direct methods
@ref{go to the find/create-test-node template-fact-alpha-node t t method, , @t{find/create-test-node}} (method)
@end table
@end deftp
@deftp {Class} template-fact-subtop-node
@anchor{go to the template-fact-subtop-node class}@c
@classsubindex{template-fact-subtop-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the template-fact-alpha-node class, , @t{template-fact-alpha-node}} (class)
@item
@ref{go to the alpha-subtop-node class, , @t{alpha-subtop-node}} (class)
@end itemize
@item Direct methods
@ref{go to the create-alpha-net% template-pattern template-fact-subtop-node method, , @t{create-alpha-net%}} (method)
@end table
@end deftp
@deftp {Class} template-fact-test-node
@anchor{go to the template-fact-test-node class}@c
@classsubindex{template-fact-test-node}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-alpha-part.lisp file, , @t{rete-alpha-part}} (Lisp file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the template-fact-alpha-node class, , @t{template-fact-alpha-node}} (class)
@item
@ref{go to the alpha-test-node class, , @t{alpha-test-node}} (class)
@end itemize
@item Direct methods
@ref{go to the test template-fact-test-node template-fact method, , @t{test}} (method)
@end table
@end deftp
@deftp {Class} template-object
@anchor{go to the template-object class}@c
@classsubindex{template-object}@c
@table @strong
@item Package
@ref{go to the exil-core package, , @t{exil-core}}
@item Source
@ref{go to the templates.lisp file, , @t{templates}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the template-fact class, , @t{template-fact}} (class)
@item
@ref{go to the template-pattern class, , @t{template-pattern}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the atom-position template-object t method, , @t{atom-position}} (method)
@item
@ref{go to the find-atom template-object t method, , @t{find-atom}} (method)
@item
@t{print-object}
@item
@ref{go to the tmpl-object-equal-p template-object template-object method, , @t{tmpl-object-equal-p}} (method)
@item
@t{tmpl-object-slot-value}
@item
@ref{go to the has-slot-p template-object t method, , @t{has-slot-p}} (method)
@item
@ref{go to the tmpl-object-slot-value template-object t method, , @t{tmpl-object-slot-value}} (method)
@item
@ref{go to the slots template-object method, , @t{slots}} (method)
@item
@ref{go to the tmpl-name template-object method, , @t{tmpl-name}} (method)
@end itemize
@item Direct slots
@defvr {Slot} template-name
@slotsubindex{template-name}@c
@table @strong
@item Initargs
@t{:tmpl-name}
@item Readers
@ref{go to the tmpl-name generic function, , @t{tmpl-name}} (generic function)
@end table
@end defvr
@defvr {Slot} slot-default
@slotsubindex{slot-default}@c
@table @strong
@item Allocation
@t{:class}
@end table
@end defvr
@defvr {Slot} slots
@slotsubindex{slots}@c
@table @strong
@item Initargs
@t{:slots}
@item Readers
@ref{go to the slots generic function, , @t{slots}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} test
@anchor{go to the test class}@c
@classsubindex{test}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the rete-beta-part.lisp file, , @t{rete-beta-part}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct methods
@itemize @bullet
@item
@ref{go to the perform-join-test test token fact method, , @t{perform-join-test}} (method)
@item
@ref{go to the test-equal-p test test method, , @t{test-equal-p}} (method)
@item
@t{print-object}
@item
@ref{go to the previous-field test method, , @t{previous-field}} (method)
@item
@ref{go to the previous-condition test method, , @t{previous-condition}} (method)
@item
@ref{go to the current-field test method, , @t{current-field}} (method)
@end itemize
@item Direct slots
@defvr {Slot} current-field-to-test
@slotsubindex{current-field-to-test}@c
@table @strong
@item Initargs
@t{:current-field}
@item Initform
@t{(error "current-field slot has to be specified")}
@item Readers
@ref{go to the current-field generic function, , @t{current-field}} (generic function)
@end table
@end defvr
@defvr {Slot} previous-condition-number
@slotsubindex{previous-condition-number}@c
tells, how many conditions back i must go@table @strong
@item Initargs
@t{:previous-condition}
@item Initform
@t{0}
@item Readers
@ref{go to the previous-condition generic function, , @t{previous-condition}} (generic function)
@end table
@end defvr
@defvr {Slot} previous-field-to-test
@slotsubindex{previous-field-to-test}@c
@table @strong
@item Initargs
@t{:previous-field}
@item Initform
@t{(error "previous-field slot has to be specified")}
@item Readers
@ref{go to the previous-field generic function, , @t{previous-field}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} token
@anchor{go to the token class}@c
@classsubindex{token}@c
@table @strong
@item Package
@ref{go to the exil-rete package, , @t{exil-rete}}
@item Source
@ref{go to the tokens.lisp file, , @t{tokens}} (Lisp file)
@item Direct superclasses
@t{standard-object}
@item Direct subclasses
@ref{go to the empty-token class, , @t{empty-token}} (class)
@item Direct methods
@itemize @bullet
@item
@ref{go to the activate beta-negative-node token method, , @t{activate}} (method)
@item
@ref{go to the get-bad-wmes beta-negative-node token method, , @t{get-bad-wmes}} (method)
@item
@ref{go to the activate beta-join-node token method, , @t{activate}} (method)
@item
@ref{go to the perform-join-tests list token fact method, , @t{perform-join-tests}} (method)
@item
@ref{go to the perform-join-test test token fact method, , @t{perform-join-test}} (method)
@item
@ref{go to the inactivate beta-memory-node token before method, , @t{inactivate}} (method)
@item
@ref{go to the broken-match beta-memory-node token method, , @t{broken-match}} (method)
@item
@ref{go to the activate beta-memory-node token method, , @t{activate}} (method)
@item
@ref{go to the complete-match beta-memory-node token method, , @t{complete-match}} (method)
@item
@ref{go to the token->list token method, , @t{token->list}} (method)
@item
@t{print-object}
@item
@ref{go to the includes-p token token method, , @t{includes-p}} (method)
@item
@ref{go to the token-equal-p token token method, , @t{token-equal-p}} (method)
@item
@ref{go to the includes-p fact token method, , @t{includes-p}} (method)
@item
@ref{go to the previous-wme token method, , @t{previous-wme}} (method)
@item
@t{negative-wmes}
@item
@ref{go to the negative-wmes token method, , @t{negative-wmes}} (method)
@item
@ref{go to the wme token method, , @t{wme}} (method)
@item
@ref{go to the parent token method, , @t{parent}} (method)
@end itemize
@item Direct slots
@defvr {Slot} parent
@slotsubindex{parent}@c
@table @strong
@item Initargs
@t{:parent}
@item Readers
@ref{go to the parent generic function, , @t{parent}} (generic function)
@end table
@end defvr
@defvr {Slot} wme
@slotsubindex{wme}@c
@table @strong
@item Initargs
@t{:wme}
@item Initform
@t{(error "wme slot has to be specified")}
@item Readers
@ref{go to the wme generic function, , @t{wme}} (generic function)
@end table
@end defvr
@defvr {Slot} negative-wmes
@slotsubindex{negative-wmes}@c
@table @strong
@item Readers
@ref{go to the negative-wmes generic function, , @t{negative-wmes}} (generic function)
@item Writers
@ref{go to the (setf negative-wmes) generic function, , @t{(setf negative-wmes)}} (generic function)
@end table
@end defvr
@end table
@end deftp



@c ====================================================================
@c Indexes
@c ====================================================================
@node Indexes, , Definitions, Top
@appendix Indexes

@menu
* Concept index::
* Function index::
* Variable index::
* Data type index::
@end menu


@c -------------
@c Concept index
@c -------------
@node Concept index, Function index, Indexes, Indexes
@appendixsec Concepts

@printindex cp

@page


@c --------------
@c Function index
@c --------------
@node Function index, Variable index, Concept index, Indexes
@appendixsec Functions

@printindex fn

@page


@c --------------
@c Variable index
@c --------------
@node Variable index, Data type index, Function index, Indexes
@appendixsec Variables

@printindex vr

@page


@c ---------------
@c Data type index
@c ---------------
@node Data type index, , Variable index, Indexes
@appendixsec Data types

@printindex tp

@bye

@c exil.texi ends here
